# 마이크로프로세서

      * 마이크로프로세서의 구조와 원리에 대해 설명할 수 있다.
      * 마이크로프로세서 칩의 종류, 동작 순서에 대해 설명할 수 있다.

## 1. 마이크로프로세서란

마이크로프로세서는 CPU와 이것저것을 통합한 것이긴 한데 CPU로 보아도 무방하다. 메모리에 내장되어 있는 명령을 해석하고 실행하는 기능을 함.

* 마이크로프로세서: Micro(아주 작은) + Processor(처리기)
* CPU(Control Processing Unit)라고 불리기도 하고, MPU(Micro Processing Unit)라고 불리기도 한다.
* 활용: IC 집적 기술, 시스템 프로그래밍 기술을 단일 칩에 집적화

### 1.1 발전 역사

1. 최초의 마이크로프로세서

1969년도 Intel 4004 : 4비트 마이크로프로세서
1980년에 개발 : Intel 8051 시리즈, 범용 마이크로프로세서, 플레시메모리로 개발, 주변장치로 활용

2. 마이크로프로세서의 종류

* Microchip (PIC) 시리즈
RISC 방식과 하버트 구조를 가진다.
고성능 8bit, 마이크로컨트를러 (마이크로프로세서 + 제어)
ISP(In-System Programming) 기능: 사용자가 작성한 프로그램을 MCU 내의 플래시 ROM에 다운로드가 가능하다.
초저가, 산업용

* Atmel (AVR) 시리즈
고성능 8bit 컨트롤러
RISC 방식과 하버트 구조를 가진다.
대용량의 플래시 메모리가 내장되어 있음.
반복적 프로그래밍 가능. 산업현장에서 사용이 증가
ISP 기능
Atmega가 인기

### 1.2 마이크로프로세서의 구조 및 구성 요소

1. 실행장치(Execution Unit)

  * 연산장치 ALU
    * Register
    * 제어장치(CU)

2. 명령어 장치(Instruction Unit)

  * 메모리에서 가져온 명령어를 저장
  * 저장된 명령어를 명령어 해석기에 명령어를 해석하여 제어 장치로 전달됨

3. 어드레싱 장치(Addressing Unit)
CPU 또는 MPU가 메모리나 입출력 장치에서 데이터를 읽거나 쓸 때, 메모리나 입출력 장치의 주소를 생성

4. 버스 인터페이스 (Bus Interface Unit)
  * 데이터 버스를 통해 외부장치들과 상호 연결: 주소가 지정되고 메모리로부터 데이터를 읽어오거나 기록할 때
  * 마이크로 프로세서 외부장치들과 상호 연결: 어드레스, 데이터, 컨트롤 버스를 통해서 한다.

### 1.3 마이크로프로세서의 동작

1. 어드레스 장치에서 명령어나 데이터가 저장되어 있는 메모리 번지를 계산한다. 어드레서 버스로 주소를 전송한다.
2. 버스 인터페이스 장치에서는 지정된 메모리 주소의 내용을 데이터 버스를 통해 읽거나 써넣는다.
3. 만약 읽어들인 데이터가 명령어이면 Prefetch Queue에 저장, 읽어들인 데이터가 Operand이면 명령어 장치는 프리패치 큐에서 명령어를 읽어서 해석(decoding)-> 해석된 명령어 (decoded instruction)를 실행장치로 전송
실행장치의 제어장치는 해석된 명령어에 따라서 ALU 및 레지스터들을 제어

### 1.4 마이크로프로세서의 분류

#### 1.4.1 설계 방식(명령어 구성 방식)에 따른 분류

1. RISC: 단순한 명령어 셋트를 지원하는 프로세서

* 명령어: 단순. 고정길이. 적은 명령어 수 (30~1000)
* Decoding: hardwired
* ~256개의 내부 레지스터
* 전력 소모가 적고 속도가 빠르며 가격이 저렴
* 호환성이 부족하다.
* 모토롤라 68계열, 매킨토시, 서버, 워크스테이션에 사용한다.
* 분리된 명령어 및 데이터 버스 사용(하버드 구조), 멀티태스킹 기능

2. CISC: 복잡한 명령어를 지원하는 프로세서

* 명령어: 복잡한 가변길이. 많은 명령어 수 (100~250)
* Decoding: micro-programmed
* 전력/속도/가격: 전력 소모가 크고 속도가 느리며 가격이 비싸다.
* 호환성이 좋음. 범용적.
* 사용 예: 386, 486, 펜티엄 등 PC용 CPU에 사용된다.
* 분리된 명령어 및 데이터 버스를 사용(하버드 구조)

#### 1.4.2. 데이터버스, ALU 및 레지스터들의 크기에 따른 분류

1. 8bit프로세서
1970년대 마이크로프로세서
소량의 마이크로컨트롤러가 존재
8051, AVR, PIC, SAM88

2. 16bit 프로세서
1980년대 초의 마이크로프로세서
8bit와 32bit발달로 많이 사용하지 않음
AM188, MSP430

3. 32bit 프로세서
1980년대 중반부터 지금까지 활발하게 사용되어 지는 마이크로컨트롤러
PC 또는 대용량의 데이터 처리를 하는 산업용 장치에 사용

#### 1.4.3. 용도(기능)에 따른 분류

1. MPU(Micro Processor Unit)
연산/제어 장치 및 각종 레지스터들을 1개의 IC 소자에 사용

2. MCU
One-Chip 프로세서: CPU, 메모리(ROM, RAM등) 입출력 제어 인터페이스 회로까지 내장한 것
MPU의 기능을 일부 축소하고 제어기능 추가
예: I8051, AVR, PIC,Cortex 등,

3. DSP
디지털 신호를 하드웨어적으로 처리할 수 있음
MPU의 기능을 일부 축소하고 고속 연산 기능 추가
특수 목적: 신호처리, 영상처리
예: TMS 시리즈

### 1.5 마이크로프로세서 관련 전자 부품

1. 기본 부품

* PCB기판 (빵판)
* 저항 (Resister)
  * 저항은 저항 값이 고정된 것과 가변되는 것, 그리고 여러 개의 저항이 하나의 부품으로 된 Array 저항이 있음.
* 콘덴서(Condeser, Capacitor)
  * 전기를 축적하는 기능
  * 잡음을 제거하거나 발진 회로를 구성할 때 자주 이용
* 다이오드 (Didode)
  * 전류를 한쪽 방향으로만 흘리는 반도체
  * 전류용 다이오드는 전원 장치에서 교류 전압을 직류 전압으로 바꿀 때 사용
  * 에노드(+) 캐소드(-) 2개 단자를 가진다.
  * 에노드 전압이 캐소드 전압보다 높을 때 전류가 흐른다.
* 트랜지스터 (Transistor)
  * 아날로그 회로에서 입력 신호를 증폭하기 위해 사용된다.
  * 디지털회로에서는 스위칭용으로 사용
  * 다이오드가 2개 연결된 것과 같은 구조를 하고 있다. 3개의 단자 E(Emitter), B(Base), C(Collector)를 가진다.
* CPU
  * 마이크로프로세서 또는 마이크로컨트롤러
* Crystal
  * CPU에 공급하는 클럭 발생을 위해 반드시 사용해야 하는 부품
  * CPU 내부의 발진 회로 단자에 콘덴서와 같이 연결하여 사용한다.
* 메모리
  * 프로그램이나 데이터를 저장하기 위해 사용된다.
* 디지털 IC
  * 마이크로컴퓨터 회로에서 디지털 논리 회로를 구성할 때 사용된다.
  * TTL(74 시리즈)이나 CMOS가 주로 사용된다.
* 스위치
  * 스위치의 상태에 따라 입력 값이 다르게 CPU로 입력되도록 회로를 구성하여 사용한다.
* 센서
* 부저(Buzzer)
  * 출력 상태를 삐 소리로 알려준다.
* LED
  * 에노드(+) 캐소드(-) 2개 단자를 가진다.
* 7-Segment
  * 숫자를 표시할 때 사용한다.
* Dot Matrix LED: 2차원적으로 LED를 배열한 것으로 문자, 기호, 여러가지 패턴을 표시한다.

## 2. 마이크로컨트롤러란

USB나 작은 기계 장치 안에 들어가는 아주 작은 컴퓨터를 뜻한다.

* 마이크로+ 컨트롤러
* 매우 작은 제어기
* 마이크로프로세서의 연산 처리기능에 제어기능이 추가된 것.

### 2.1 마이크로프로세서와 마이크로컨트롤러

      시스템 버스: CPU와 시스템 버스 간의 접속
      * 주소버스: 단방향성(unidirectional)
        - CPU에서 외부로 발생하는 주소 정보 전송 신호선 
        - 주소 선의 수는 CPU와 접속되는 최대 기억장치 용량 결정 
        - 주소 버스의 비트 수 = 16비트라면, 최대 2 ^ 16 = 64K개의 기억 장소들의 주소지정이 가능하다.
      * 데이터버스: 양방향성(bidirectional)
        - CPU가 기억장치 또는 I/O 장치간의 데이터 전송 신호 선
        - 데이터 선의 수는 CPU가 한번에 전송할 수 있는 비트 수를 결정
        - 데이터 버스 폭 = 32비트라면 CPU와 기억 장치 간의 데이터 전송은 한 번에 32 비트씩 가능하다.
      * 제어버스: 양방향성(bidirectional) 읽기와 쓰기 동작을 모두 지원한다.
        - CPU가 시스템 내의 각종 장치들의 동작을 제어하기 위한 신호 선
        - 기억장치의 읽기/쓰기(memory read/write) 신호
        - 입출력 장치의 입력/출력 (I/O input/output) 신호
        - 인터럽트 신호
        - 버스제어 신호

### 2.2 마이크로컨트롤러 구조

입력장치 (센서, 스위치)에 붙어서 이 장치로 신호가 들어오고 메모리에 신호가 저장된다.
제어기능에 대한 출력장치는 모터, Display로 나옴.

### 2.3 마이크로컨트롤러의 장단점

1. 장점

* 제품의 소형화 및 경량화
* 저렴한 가격
* 신뢰성 향상
* 융통성

2. 단점

* 낮은 처리 능력
* 범용성 부족

## 3. 마이크로컨르톨러 : ATmega128이란?

      * ATmega128의 특징
      * ATmega128의 메모리와 주변장치 및 동작 환경

### 3.1 ATmega128

고 성능의 저 전력 8비트 마이크로컨트롤러

* Atmel 사에서 개발 출시하는 AVR시리즈
* 지보된 RISC구조
  - 133개의 강력한 명령어: 대부분 1클록 사이클에서 실행
  - 단일 클럭 내에서 하나의 명령어를 실행(1MHz당 1MIPS의 성능)

### 3.2 ATmega128의 특징

#### 3.2.1 진보된 RISC 구조

* 32개의 레지스터(* 레지스터: ALU에 중간 계산 결과 값을 저장한다.)
  - ALU에 직접 연결
  - 1클럭 사이클 내에 하나의 명령어로 두 개의 레지스터를 액세스
  * CISC 마이크로컨트롤러에 비해 약 10배 정도 효율
* 처리 성능: 16MHz ~ 16MIPS
* 2클록 사이클이 소요되는 곱셈기를 칩에 내장

#### 3.2.2 비휘발성 프로그램과 데이터 메모리

* ISP 방식의 플래시 메모리 내장: 10,000회 읽기/쓰기 가능
* 4Kbyte의 EEPROM(*ROM: 원래는 한 번 기록하고 나면 다시 기록할 수 없) 100,000회 읽기 / 쓰기 가능
* 4Kbyte의 SRAM 내장
* 외부 추가 사용 가능 메모리 공간: 64Kbyte까지
* SPI 인터페이스를 이용한 ISP(In System Programming) 가능

참고
RAM  | ROM
-----|-------
휘발성 | 비휘발성
여러번 읽고 쓸 수 있음 | 여러번 읽을 수는 있으나 한 번만 기록할 수 있음.

#### 3.2.3 주변창치(Peripheral Device)

1. 7개의 I/O 포트
  - 8비트 I/O 포트 - A, B, C, D, E, F
  - 5비트 I/O 포트 - G
2. 2개의 8비트 타이머/카운터
  - 별도의 프리스케일러와 비교 모드 동작
3. 2개의 16비트 타이머/카운터
  - 별도의 프리스케일러, 비교모드, 캡처 모드 동작
4. 발진 회로와 분리된 실시간 타이머 카운터
5. 6개의 PWM 채널: 2~16비트까지 조정 가능
6. 출력 비교 모듈레이터
7. 2개의 USART
8. 아날로그 비교기
9. 8채널의 10비트 A/D 변환기 (ADC:Analog to Digital Converter)
  - 8개의 단극성 입력 채널: 그라운드(GND) 신호와 입력 신호(Vi) 사이의 전위차
  - 7개의 차동 입력 채널: 두 입력 신호 사이의 전위차 (Vp-Vn)
  - 2개의 프로그램 가능한 입력 이득(1x, 10x, 200x)을 갖는 채널
10. 2선식 직렬 인터페이스(TWI: Two-wire Serial Interface): 바이트 지향
11. 2개의 USART: RS232통신, RS485 통신 등에 적용
12. Master/Slave SPI 직렬 인터페이스
13. 프로그램 가능한 와치독 타이머 (Watchdog Timer): 내부 발진 회로와 연결
14. JTAG(IEEE std. 1149.1 호환) 인터페이스
  * JTAG 표준에 따른 Boundary-scan 수용
  * 온-칩 디버깅 지원
  * JTAG 인터페이스를 통해 플래쉬, EEPROM, 휴즈, 락비트 프로그래밍

      [참고] JTAG 인터페이스
        - 칩데이터
        - FPGA 구울 때 쓴다.
        - 디버깅하고 플래시 메모리 프로그래밍 (ISP) 할 때 쓴다.

### 3.3 ATmega128의 내장 기능

#### 3.3.1 특수기능

* Power-On 리셋: 외부 별도 리셋 회로 없이 전원 인가 (레지스터 초기화)
* 브라운아웃(Brown-Out) 전압 검출: 2.7V 또는 4.3 이하의 전원 전압을 검출
* 프로그램으로 조율이 가능한 내부 RC 발진 회로
* 6개의 휴먼 모드: Idle, A/D 변환기 잡음 제거, 파워-세이브(Power-Save), 파워-다운(Power-down), 대기(Standby), 확장 대기(Extended Standby)
* 소프트웨어적으로 선택 가능한 클럭 주파수
* 휴즈 비트로 ATmega103호환 모드 선택
* 전체 풀업(Pull-up) 저항해제

### 3.4 ATmega128의 내부 구조

#### 3.4.1 주요 구성 요소

1. 8-bit ALU
2. 내장 메모리

2.1. 플래시 프로그램 메모리

- 특징 : 비휘발성 메모리
- 용량: 128Kbyte
- 10,000 쓰기, 지우기 반복 가능

2.2. 데이터 메모리(SRAM)

- 프로그램에 선언한 변수와 스택을 위해 읽고 쓰기를 빠르게 수행할 수 있는 주 메모리(휘발성 메모리)
- 용량: 4Kbyte

2.3 EEPROM

- 프로그램 실행 중 생성된 데이터 전원 없이도 유지
- SRAM, 플래시 프로그램 메모리보다 시간이 오래 걸림
- 용량: 4Kbyte

3. 입출력 장치

4. 기타

- 패키지: 64핀
- 동작 주파수: ~16MHz
- 동작 환경: -40~80℃
- 전원전압: 2.7~5.5V

#### 3.4.2 ATmega128의 내부 구조

1. On-Chip I/O Device

* GPIO(General Purpose I/O)
  - 범용 입출력 포트로 53개의 프로그램 가능
  - 6개의 8bit 포트: A, B, C, D, E, F 포트

2. Peripheral Device

* 타이머
  - 8-Bit 2개, 16-Bit 2개의 8-Bit 타이머
  - 실시간 클럭(Real Time CLock) 구성 가능

* Watchdog 타이머
  - 타임아웃 주기를 프로그램 가능
  - 별도 내부 발진기 사용

* PWM(Plus Width Modulation)
  - 입력 값에 따라 펄스 폭 변조
  - 2채널의 8-Bit, 6-채널의 PMW

* 아날로그 인터페이스
  - 8-채널의 10-Bit ADC
  - 아날로그 비교기

* USART
  - 범용 동기/비동기 시리얼 포트
  - 2-포트

* SPI(Serial Peripheral Interface)
  - 전이중 동기 시리얼 인터페이스
  - 플래시 메모리 프로그램에 사용
  - 3선(MISO(Master In Slave Out: Output From Master), MOSI(Master Out Slave In: Data output from master), SCLK(Serial CLock: Ouput from master)) 사용
  - 최대 전송속도: 시스템 클럭 주파수 / 4

* TWI(Two-wire Serial Interface)
  - 동기 시리얼 인터페이스
  - 필립스의 Inter-IC와 동일
  - 2-선 (SDA(Serial Data), SCL(Serial Clocks)) 사용
  - 전송속도: 400KHz

* 프로그램 카운터 (Program Counter)
  - 플래시 프로그램 메모리 공간을 가리킨다.
  - 명령어를 차례로 인출하면서 응용프로그램을 실행한다.
  - 다음에 수행할 명령어의 address를 가진다.

* 명령어 레지스터
  - 프로그램 카운터가 지칭한 곳에서 명령어 레지스터로 명령어 인출
  - 명령어에는 명령코드, 오퍼랜드, 연산 결과 저장 위치 필드를 가짐

* 명령어 디코더
  - 명령어 레지스터의 명령 코드를 디코딩해서 제어 신호를 생성한다.
  - ALU는 명령코드에 해당되는 연산동작을 수행하게 한다.
  - 제어 신호는 연산 대상이 되는 오퍼랜드가 ALU에 전달되게 한다.
  - 제어 신호는 연산결과를 저장할 수 있게 한다.

* 스택포인터
  - 스택은 임시데이터, 로컬변수, 호출된 함수의 복귀 주소 등을 저장한다.
  - 스택 포인터(Stack Pointer)는 스택의 TOP을 저장하는 특수 레지스터
  - 스택 데이터가 저장되면 스택 공간은 커진다.
  - 스택 포인터의 주소는 높은 값에서 낮은 값으로 감소
  - PUSH 명령어: 데이터가 스택에 저장 (스택 포인터는 1씩 증가한다.)
  - POP 명령어: 데이터를 스택의 TOP에서 꺼냄.

#### 3.4.2 ATmega128의 동작환경

* 동작 주파수
  * ATMega128A: ~16MHz
  * ATmega128: ~16MHz
  * ATmega128L: ~8MHz

* 공급 전원
  * ATmega128A: 2.7 ~ 5.5V
  * ATmega128: 4.5 ~ 5.5V
  * ATmega128L: 2.7 ~ 5.5V

* 동작 온도
  * 상용: 0 ~ 70도
  * 산업용: -40 ~ 85도

* ATmega128의 패키지
  * 64-lead TQFP(Thin Quad Flat Package)
  * 64-pad MLF(Micro Lead Frame)

* ATmega128의 핀
  * 64개의 핀
  * 패키지는 TQFP(Thin Quad Flat Package)와 MLF(Micro Lead Frame)
  * 기본용도: 입출력 포트용
  * 대체용도: 프로세서에 내장된 입출력 장치의 신호선

## 4. ATmega128 개발 환경 구축하기

    * AVR studio 사용하기
    * 프로그램을 컴파일하여 실행파일을 생성할 수 있다.

프로그램 작성 -> 컴파일 OR 어셈블러 -> 링커 (컴파일된 결과 파일을 하나로 통합하고 기존에 작성된 라이브러리를 연결한다.) -> ISP 다운로드

### 4.1 프로그램 개발에 필요한 도구

1. Compiler: 고급언어로 작성된 프로그램을 기계어로 번역 (*.o)
2. Cross Compiler
  - 다른 프로세서로 목표로 하는 시스템의 컴파일
  - PC에서 AVR용 기계어 코드로 번역
3. Assembler: 어셈블리어로 작성된 프로그램을 기계어로 번역
4. Cross Assembler: 다른 프로세서로 목표로 하는 시스템의 기계어 번역
5. Linker: 
  - 여러 개의 컴파일 (또는 어셈블) 결과 파일을 하나로 통합
  - 기존에 작성된 라이브러리를 연결
6. Hex 파일 컨버터
7. Debugger

## 5. 디지털 컴퓨터와 2진법 알기

    * 디지털과 아날로그 시스템의 차이점을 이해하고, 디지털 논리연산을 수행할 수 있다.
    * 주어진 수를 2진법, 8진법, 16진법으로 변환할 수 있다.
    * Overflow와 Underflow가 발생하는 이유를 설명할 수 있다.

### 5.1 아날로그와 디지털

1. 아날로그(Analog)

* 끊이지 않는 연속성 데이터
* 소리, 빛, 무게 등과 같은 자연계의 모든 신호
* 아날로그는 노이즈에 취약하여 아날로그로 저장한 후 사용할 수록 손실 발생
* 가장 정확한 참 값
* 신호의 특성상 압축이 어렵다.
* 훼손된 정보는 원래 데이터 복원이 불가능하다.

2. 디지털(Digital)

* 일정한 시간 단위로 끊어진 데이터
* 0과 1로 이루어지는 이진법 논리를 사용해서 0과 1의 각종 조합을 만든 후 그것의 조작과 처리를 통해 여러가지 정보를 생산,유통,전달할 수 있도록 만든다.
* 현대에 사용되는 대부분의 정보 시스템에서 사용
* 압축이 가능하다.
* 일정 수준 이하의 훼손일 경우 복원이 가능하다.

### 5.2 아날로그 시스템과 디지털 시스템

1. 아날로그 시스템

* 연속적인 정보를 입력 받아 처리하여 연속적인 정보를 그래프 형태로 출력하는 시스템
* 미세한 변화에도 출력 변화가 있게 되므로 신호 값이 연속적으로 처리되어 정확한 구분이 어려움
* 증폭 회로 사용

2. 디지털 시스템

HD 방송을 고화질로 볼 수 있는 이유는 방송 신호를 디지털 신호로 변경한 다음 MPEG로 압축하여 전송하기 때문이다. 

* 측정 오차가 없이 정확도가 높아, 신뢰도가 높음
* 디지털 집적 회로의 제작이 용이하고 경제성이 높음
* 집적 회로의 발달로 저렴한 비용 고용량 저장이 가능
* 잡음에 가능하고 손실이 거의 없음
* 통신 및 자료처리, 자동제어, 의료기 분야에 이르기까지 다양하게 사용
* 논리 회로를 사용한다.

3. 아날로그 신호와 디지털 신호의 교환

A/D Converter와 D/A Converter을 이용해서 아날로그 신호를 디지털 신호로, 디지털 신호를 아날로그 신호로 교환한다. 

### 5. 논리회로

* 컴퓨터는 0 (거짓, OFF 상태), 1(참, ON) 상태라는 두 가지 상태만을 다루는 2진법 체계인데, 내부의 회로들은 이러한 두 상태 간의 어떤 논리에 의해 작동이 된다.
* 2진 정보 체계로 작동되는 어떤 논리를 가진 회로를 논리회로라고 하고, 그 구성소자로는 회로(gate)와 flip-flop(참과 거짓이 왔다갔다 하는 것)이 있음.

#### 5.1 기본 논리 회로

논리를 가진 논리 회로의 기본 소자로서 AND, OR, NOT, NAND, NOR, XOR가 있음. 

1. AND: 모두 참이면 결과도 참

기호: 
논리식: X = A * B 또는 X = A ^ B
진리표

A | B | X
--|---|---
0 | 0 | 0
0 | 1 | 0
1 | 0 | 0
1 | 1 | 1

2. OR: 둘 중 하나가 참일 때 결과도 참

기호:
논리식: X = A + B 또는 X = A B

3. NOT: 참이면 결과가 거짓, 거짓이면 결과가 참

기호:
논리식: X = A'
논리식

A |  X
--|----
0 | 1
0 | 0

4. NAND(논리곱 부정): 둘 다 참일 때 결과가 거짓

기호: 
논리식:
진리표: 

5. NOR(논리합 부정): 둘 다 거짓일 때 결과가 참

6. XOR(배타적 논리합) 회로: 둘의 논리값이 다를 때, 결과는 참

A | B | X
--|---|---
0 | 0 | 0
0 | 1 | 1
1 | 0 | 1
1 | 1 | 0

#### 5.2 진법과 연산 방법

1. 진법

- 수를 표기하는 기수법의 하나로 임의의 숫자를 사용하여 수를 표현하는 방법
- 일반적으로 사용하는 1부터 9까지의 숫자를 사용하여 수를 나타내는 방법은 10진법이라고 부른다.

2. 2진법

- 컴퓨터 정보 표현 방법
- 0과 1, 두 개의 숫자만으로 수를 표현하는 방법
- 컴퓨터에서는 2진수의 한 자리를 비트(bit)라는 용어를 사용하여 가리키며, 이러한 비트가 8개 모여 1바이트(byte)를 구성
  - 1byte = 8bit

3. 8진법

- 0~7, 8개의 숫자만으로 수를 표현하는 방법
- 2진수를 3자리씩 묶어서 표현할 수 있어, 초창기 컴퓨터에서 많이 사용

4. 10진법

- 0~9, 10개의 숫자만으로 수를 표현하는 방법
- 일상 생활에서 주로 사용하는 숫자 표기 방법

5. 16진법

- 0~9의 숫자와 A~F까지의 문자를 함께 사용하여 수를 표현하는 방법
- 2진수를 4자리씩 묶어서 표현할 수 있음
- 1개의 16진수는 4자리 2진수로 표현됨
- A ~ F의 문자는 10 ~15를 의미한다.

#### 5.3 진법과 변환

5.3.1. 10진수를 각 진법으로 변환하는 방법

(1) 10진값을 변환하고자 하는 기수로 나눈다. (2진법이면 2가 기수)
(2) 나눈 나머지를 기록
(3) if 나눈 몫 < 기수:
(3-1) yes: 마지막 몫과 지금까지 기록한 나머지들을 연결
(3-2) no: 나눈 몫을 변환하고자 하는 기수로 나눈다

5.3.2. 컴퓨터에서의 데이터 표현

* MSB: 부호비트
  - 양수: 0
  - 음수: 1

* 크기: Bit(1bit) -> Nibble(4bit) -> Byte(8bit) -> Word(2byte) -> paragraph(16byte) -> Page(256 byte)

5.3.3. 진법 연산

* 덧셈 연산
* 뺄셈 연산: 가장 먼저 자릿수를 맞추는 것이 가장 중요
  * 2진수 음수를 표시하는 방법
    - 부호와 절대치 표현 방법: 부호 비트를 제외한 값에 -부호를 붙임
    - 1의 보수: 부호 비트를 제외한 값을 1의 보수: 0은 1로, 1은 0으로 바꾸고 - 부호를 붙임
    - 2의 보수: 부호 비트를 제외한 값의 1의 보수 +1에 0부호를 붙임 (가장 일반적으로 사용하는 방법)
  * 2진수 음수의 3가지 표현
    * 8 bit 크기이며 최상위 비트인 MSB가 부호 비트임

2진수 | 부호와 절대치 | 1의 보수 | 2의 보수
-------|---------|---------|-------
10000000| -0     |  -127   | -128
10000001| -1     |  -256   | -257

  * N진수 음수를 표시하는 방법
    * 부호와 절대치: 부호 비트를 제외한 값에 - 부호를 붙임
    * N-1의 보수: 부호 비트를 제외한 값의 각 자리의 수를 N-1 숫자로 구함
    * N-1의 보수 + 1

  * N진수 음수의 3가지 표현

진수  | 음수  | N-1의 보수    | N의 보수
-----|-----|--------------|----------------
8진수 | -15 | 77 - 15 = 62 | (77-15)+1 = 63
10진수| -15 | 99 - 15 = 84 | (99-15)+1 = 85
16진수| -15 | FF-15=EA     | (FF-15)+1 = EB

* 자릿수가 다른 숫자의 뺄셈 연산할 때: 두 수의 자릿수를 맞추기 위해 부족한 자리는 0으로 채움

5.3.4 수의 표현 방법: 부호 있는 1Byte => 2^8 = 256개의 수 (-128 ~ 127)

* Overflow: 가장 큰 수 + 1: 덧셈 연산에서 주로 발생
  * 부호 없는 1Byte의 수: 덧셈 결과가 2^8 -1 (FF)보다 클 때
  * 부호 있는 1Byte의 수: 덧셈 결과가 2^7 -1 (7F)보다 클 때
  * 부호 없는 2Byte의 수: 덧셈 결과가 2^16 -1(FFFF)보다 클 때
  * 부호 없는 2Byte의 수: 덧셈 결과가 2^15 -1(7FFF)보다 클 때
* Underflow: 가장 작은 수 + 1: 뺄셈 연산에서 주로 발생
  * 부호 없는 1Byte의 수: 뺄셈 결과가 0(00)보다 클 때
  * 부호 있는 1Byte의 수: 뺄셈 결과가 -2^7(80)보다 클 때
  * 부호 없는 2Byte의 수: 뺄셈 결과가 0(0000)보다 클 때
  * 부호 없는 2Byte의 수: 뺄셈 결과가 -2^15(8000)보다 클 때

마이크로프로세서에서는 이와 같은 상황이 발생했을 때 해당 플러그(Flog)를 Set시킴으로써 에러를 발생시킨다.

## 6. C언어 기초 익히기

* variable: 어떤 값(데이터)을 메모리에 저장하는 공간의 이름
* keyword: C컴파일러가 이미 사용중인 단어들
* 식별자: 프로그래머가 명명하는 여러 키워드로 변수 이름, 함수 이름 등이 여기에 속함

## 6.1 C언어의 특징

* 1972년 벨 연구소에서 UNIX시스템을 개발하기 위해 개발한 언어
* 빠른 처리 속도
* 사람이 쉽게 이해하고 있을 수 있음 (고급언어)
* 어셈블리어 수준의 강력한 기능 (저수준 언어: 프로그래밍에 많은 주의 필요)
* 언어의 각 구성요소가 상호독립적이고, 서로 다른 컴퓨터 상에서 항상 같은 결과를 출력
* 마이크로프로세서 프로그래밍에 많이 사용

### 6.1.1 C언어의 장단점

장점

* 이식성 뛰어남
* 간편한 제어구조 및 다양한 연산자 제공으로 효율성이 높음
* 다양한 분야에서 사용(범용 언어)
* 뛰어난 유연성 (소프트웨어 부품와 실현 가능)
* 혼합성 (다른 언어와 함께 사용될 수 있음 : 클리퍼 = C+어셈블리)
* 절차지향적 언어

단점
* 완전 고급 언어에 비해 배우기 어려움
* 자료형의 검사 기능 미약
* 혼합 연산의 경우, 연산 우선 순위를 모르면 잘못된 계산 결과를 얻을 수 있음
* 배열의 첨자 범위 검사 기능 미약
* 모듈화하지 않으면 가독성이 떨어지는 경우가 많음

### 6.1.2 예약어(Reversed word)와 식별자(Identifier)

예약어

* C 컴파일러가 이미 사용중인 단어들
* 변수나 함수이름으로 사용될 수 없음
* `auto`, `for`, `double`, `flaot`, `int`, `char`, `void`, `sizeof`, `extern`,`do`, `return`, ...

식별자

* 프로그래머가 명명하는 여러 키워드 (변수이름, 함수이름 등)
* 식별자는 영문자, 숫자와 밑줄 (_)만 사용
* 식별자의 첫 글자는 숫자 불가
* 대소문자는 구별됨
* 예약어는 사용할 수 없음
* 최대 255자 까지 가능
* 올바르지 않은 식별자: `1two, Number#1, After function, void`

### 6.1.3 C언어의 기본 구조

```c
/* 선행처리부: 컴파일러보다 먼저 처리할 것을 표시하는 부분 */
#include <avr/io.h>
#include <util/delay.h>

/* 선언부: */
void mesc_delay(int n); // 사용자 정의 함수 프로토타입
Unsigned char pattern[8] = {0xFE, 0xFD, 0xFB, 0xF7, 0xEF, 0xDF, 0xBF, 0x7F}

/* 실행부 : 실제적으로 수행하는 처리절차를 기술한 부분 */
int main() { // C언어는 반드시 하나의 main 함수를 갖는다.
  int i = 0;
  DDRA=0xFF;
  PORTA=pattern[i];
  whlie (1) {
    mesc_delay(1000);
    if(++i==8) i = 0;
    PORTA = pattern[i]
  }
}
/* 사용자 함수 정의부: 실제 수행할 함수에 대한 처리 절차를 기술한 부분 */
/* 사용자 정의 시간 지연 함수 */
Void mesc_delay(int n) {
  For(;n >0; n--) 
    _delay_ms(1); // AVR에서 제공하는 지연 함수
}
```

### 6.1.4 소스 코드 입력 규칙

* 명령 줄에는 `;`을 찍음
* 여러 개의 명령줄을 블록으로 묶을 때는 {} 사용
* 한 블록을 구분하는 중괄호의 {과 }은 같은 열에 맞춤
* 블록 내에서 들여쓰기 통일 (중괄호 보다 1단계 들여쓰기: space 3~5, tab 1회)

## 6.2 변수와 메모리

### 6.2.1 변수

6.2.2.1 변수의 개념

* 어떤 값 (데이터)을 메모리에 저장하는 공간의 이름
* 그 크기와 용도에 따라 여러 종류가 존재
* 선언되는 순간, 메모리에 공간이 할당됨
* 중괄호 "{, }" 내에서 선언된 변수는 이를 벗어나면 자동으로 소멸 (자동변수 또는 지역변수)
* 메모리 상의 주소(Address)는 컴파일러가 상황에 따라 결정

Address | Data
--------|-----
 0x0100 | ??? (Garbage Value)
 0x0101 | ??? (Garbage Value)
 0x0102 | ??? (Garbage Value)
 ....   | ...

변수 a의 주소: 0x0101, 변수 a 의 값 = 10
`char a = 10;` 상수 10을 변수 a에 저장하라

Address | Data
--------|-----
 0x0100 | ??? (Garbage Value)
 0x0101 | 10
 0x0102 | ??? (Garbage Value)
 ....   | ...

* 마이크로 컨트롤러의 RAM 용량에 따라 그 크기 / 개수가 제한
* 변수의 이름
  * 식별자의 규칙 적용
  * 의미 있는 단어의 사용과 적당한 접두어가 혼란을 줄여줌

6.2.2.2 변수의 선언

* 자료형 변수명
예: `int count;`
  - 메모리의 어느 위치에 count라는 이름의 공간을 확보, Garbage Value
  - 초기화되지 않은 변수는 사용에 주의할 필요가 있음

* 초기화된 변수 선언
예: `int count=0;`
  - 메모리 공간을 확보하고 그 값에 0을 저장

### 6.2.2 변수와 메모리

6.2.2.1 변수의 선언과 메모리 할당

* 변수를 선언하면 적절한 주소(Address)에 메모리가 할당됨
* 변수를 읽고 쓰면 CPU가 Memory에 주소를 지정하고, 값(Data)을 주고 받음

메모리(RAM) <- CPU (MCU): 해당 변수의 메모리 주소 지정
메모리(RAM) -> CPU (MCU): 데이터를 주고 받음

변수 | 주소        | 값
----|------------|---
  . | 0x0040DF00 | ??? (쓰레기 값 또는 다른 변수 값)
  . | 0x0040DF04 | ???
data| 0x0040DF08 | 100 (할당된 주소의 값)
  . | 0x0040DF0C | ???
  . | 0x0040DF10 | ???

* 변수의 자료형에 따른 범주
  * 변수의 저장 범위와 형태를 지정하여 메모리의 크기와 저장 방법을 지정
  * 예상되는 범위를 미리 예측하여 변수의 크기를 지정 -> 불필요한 메모리의 낭비 방지

 자료형  | 비트 수 | 바이트 수 | 값 범위    | 설명
 ------|--------|--------|-----------|-------------------
`char` |    8  |     1   | -128~127 | 부호 있는 2^8개의 정수
`unsigned char` | 8 | 1 | 0 ~ 255 | 부호 없는 2^8개의 정수
`signed char` | 8 | 1 | -128 ~ 127 | = char(signed 생략 가능)
`short int` | 16 | 2 | -32768 ~ 32767 | 부호 있는 2^16개의 정수
`unsigned int` | 16 | 2 | 0 ~ 65535 | 부호 있는 2^16개의 정수
`signed int` | 16 | 2 | -32768 ~ 32767 | = int
`long int` | 32 | 4 | -2^31 ~ 2^31 -1 | 부호 있는 2^32개의 정수
`unsigned long int` | 32 | 4 | 0 ~ 2^32 -1 | 부호 있는 2^32개의 정수
`signed long int` | 32 | 4 | -2^31 ~ 2^32 -1 | 부호 있는 2^32개의 정수
`float` | 32 | 4 | ±1.175e-38 ~ ± 3.402e38 | 부동소수점 실수
`double` | 32 | 4 | ±1.175e-38 ~ ± 3.402e38 | 부동소수점 실수

*주*: 강의 자료에는 double이 32비트라고 나와있지만, 스펙상 비트 수가 따로 정해진건 아니고 어느 컴파일러를 써서 어느 CPU를 대상으로 컴파일 하느냐에 따라 다르다. 다만 대부분 64비트.
*주*: double의 유래는 double precision floating point.

## 6.3 연산자와 제어문

### 6.3.1 연산자

분류 | 연산자 | 설명 
----|------|-----
산술 연산자 | `+`, `-`, `*`, `/`, `%` | 산술 연산을 수행함
관계 연산자 | `>`, `<`, `==`, `!=`, `>=`, `<=` | 두 크기를 비교
증감 연산자 | `++`, `--` | 1씩 증가 또는 감소
논리 연산자 | `&&`, `||`, `!` | 논리 연산을 수행
조건 연산자 | `?:` | 조건에 따른 대입
비트 논리 연산자 | `&`, `|`, `^`, `~` | 변수의 비트 단위 논리 연산
비트 이동 연산자 | `<<`, `>>` | 변수의 비트 단위 이동 연산
대입 연산자 | `=` | 오른쪽 값을 왼쪽에 저장
대입연산자의 축약형 표현 | ex) `a += 2` | `a = a+2`
변수의 크기 | `sizeof()` | `sizeof(a)` -> a의 크기 (byte) 반환
cast 연산자 | (변수형) | 임시로 변수의 형을 반환

## 6.4 함수와 매개변수

### 6.4.1 함수

6.4.1.1 특징

- 특정한 기능의 프로그램을 작성하여 묶어서 관리
- 함수를 호출하여 같은 기능을 반복적으로 사용
- 간결한 프로그래밍, 유지보수, 관리 편리
- 다른 프로그램에서도 재사용 가능
- 여러 번 호출 시 메모리 효율성 증대
- C언어는 함수의 모음이다.
- 반드시 있어야 하는 함수: main() 함수 (명령의 흐름이 시작된다.)

```c
사용자 함수 정의 형식

반환형식 함수명([인자1, 인자2, ...]) {
  실행문장;
  return 반환값;
}
```

- 반환 형식: 함수의 실행 결과 반환 데이터의 자료형 (반환 값이 없으면 void로 적는다.)
- return 문 (결과값 반환)을 만나면 무조건 종료된다.

6.4.1.2 함수의 선언과 호출

```c
#include<avr/io.h>
#include<util/delay.h>
void msec_delay(int n); // 사용자 정의 함수 프로토타입: 컴파일러에게 함수의 존재와 형태를 알려준다.
Unsigned char pattern[8] = {0xFE, 0xFD, 0xEF, 0xDF, 0xBF, 0x7F} // 전역변수

int main() {
  int i = 0;
  DDRA=0xFF;
  PORTA=pattern[i];
  while (1) {
    msec_delay(1000); // 함수 호출(인자 전달), 함수의 return 값을 반환하고 있지 않는다.
    if(++i==8)i=0;
    PORTA=pattern[i];
  }
}
/*사용자 정의 시간 지연 함수*/
void msec_delay(int n) {
  for(;n>0;n--) {
    _delay_ms(1); // AVR에서 제공하는 지연 함수
  }
}
```
6.4.1.3 함수의 선언과 호출

* 지역변수(Local Variable)
  * 중괄호 안에서 선언된 변수
  * 중괄호를 벗어나면 자동으로 소멸된다

* 전역변수(Global Variable)
  * 모든 중괄호 밖에 선언된 변수
  * 모든 영역에서 사용된다.
  * 프로그램이 종료되는 시점에 소멸된다.

6.4.1.3 라이브러리 함수

* 수학 함수 등 복잡하거나 자주 사용하는 함수를 라이브러리에서 호출한다.
* 해당 함수가 들어있는 헤더파일을 include 할 것
* ex) AVR의 math.h 헤더 파일: 수학관련 라이브러리 함수 모음

함수명 | 함수의미
------|------
double cos(double x) | x의 코사인 값 계산
double sqrt(double x) | x의 제곱근 계산
double fabs(double x) | x의 절대값 계산

6.4.1.4 정적변수 (Static Variable)

* 지역변수의 특성과 전역 변수의 특성을 모두 가진 변수
* 사용은 블록 내에서만 사용 가능하지만 변수의 소멸을 프로그램이 종료되는 시점에 있다.
* 중괄호를 벗어나도 변수의 값을 유지하고자 할 때 static 키워드를 변수의 선언 앞에 사용한다.

```c
int main() {
  int res;
  res = add(1); // res = 1
  res = add(1); // res = 1
  res = add(1); // res = 1
  return 0;
}

int add(int x) {  
  // 함수가 종료되면 소멸하는 res 변수
  int res = 0;
  res = res + x;
  return res;
}
```

```c
int main() {
  int res;
  res = add(1); // res = 1
  res = add(1); // res = 2
  res = add(1); // res = 3
  return 0;
}
int add(int x) {
  // 함수가 종료되어도 소멸되지 않고 변수의 값이 저장된다. 
  static int res = 0;
  res = res + x;
  return res;
}
```

6.4.1.5 매개변수:

- 함수 호출 시 값을 전달하고자 할 때 사용하는 것으로 전달할 값이 없으면 생략이 가능
- 함수 정의 부분의 매개변수를 형식 매개변수라 하고, 호출 문장의 매개변수를 실 매개변수라 함

## 6.5 배열과 포인터

### 6.5.1 배열(Array)

6.5.1.1 1차원 배열의 특징

* 동일한 타입의 변수를 n개 묶어서 선언된 변수
* 0부터 시작하여 n-1까지 할당된다.
* `int data[5] = {1, 2, 3}`의 나머지는 0으로 채워진다.

```c
#include <avr/io.h>
/*
 * 배열의 선언 
 * 자료형 변수[크기];
 * 배열의 초기화
 * 자료형 변수명[크기] = {...}; 또는 자료형 변수명[] = {...};
 */

int main(void) {
  int i;
  int data[5] = {1, 2, 3, 4, 5};
  int sum = 0;
  for (i=0;i<5;i++) {
    sum = sum + data[i];
  }
}
```

6.5.1.2 2차원 배열의 특징

* `int data[2][5] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}};`

```c
#include <avr/io.h>

int main(void) {
  int i, j;
  int data[2][5] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}};
  int sum = 0;

  for (i=0; i<2;i++) {
    for (j=0; j<5; j++) {
      sum = sum + data[i][j];
    }
  }
}
```

6.5.1.3 배열과 메모리 할당

* 배열의 선언과 초기화
`int data[5] = {0, 1, 2, 3, 4};`

배열 요소(변수) | 주소 | 값
-------------|-----|----
data[0] | 0x0040DF00 | ????
data[1] | 0x0040DF04 | 0
data[2] | 0x0040DF08 | 1
data[3] | 0x0040DF0C | 2
data[4] | 0x0040DF10 | 3
data[5] | 0x0040DF14 | 4
. | 0x0040DF18 | ????

### 6.5.2 포인터(Pointer)

6.5.2.1 개념

* 다른 변수 혹은 그 변수의 메모리 공간 주소를 가리키는 변수
* 역참조: 포인터가 가리키는 값을 가져오는 것
* 메모리 주소를 바꿀 수 있어서 다른 변수나 함수를 가리키도록 사용
* 포인터 변수의 선언
  * 변수 앞에 *을 붙여 선언
  * 포인터 변수의 값을 주소로 간주, 주소의 값을 가져온다. (Indirect Access)
  * *가 붙으면 저장된 주소가 가르키는 값, 없으면 저장된 주소

6.5.2.2 목적

* 변수의 메모리 주소 알아내기
  * 변수 앞에 &를 붙임

```
int data = 100;
%data -> 0x0040DF0C
```

6.5.2.3 배열을 포인터로 접근하기

* 포인터 변수를 선언
* 포인터 변수의 주소에 배열의 첫 주소를 저장
* 포인터 변수로 배열 변수를 읽고 쓰기

```c
#include <avr/io.h> 

int main() {
  int a[5] = {0, 1, 2, 3, 4};
  int *ptr;

  ptr = &a[0];  // 변수 a의 주소값을 ptr에 저장
  b = *(ptr+1); // a[1]과 같음, b = 1

  // &a[0] -> &*(a+0) -> (a+0) -> a
  return 0;
}
```

포인터 | 변수 | 주소 | 값
------|----|-----|----
. | .   | 0x0040DF00 | ????
*(data + 0) | a[0] | 0x0040DF04 | 0
*(data + 1) | a[1] | 0x0040DF08 | 1
*(data + 2) | a[2] | 0x0040DF0C | 2
*(data + 3) | a[3] | 0x0040DF10 | 3
*(data + 4) | a[4] | 0x0040DF14 | 4
. | . | 0x0040DF18 | ????

6.5.2.4 주의사항

* 할당되지 않은 영역은 쓰기 금지
* 다른 변수가 사용할 수 있음
* 프로그램의 이상 동작 가능성 있음
* 별도의 보호 기능이 없고 프로그래머의 책임임
* 선언되지 않은 값 쓰지 말 것

### 6.5.3 전처리기

6.5.3.1. 전처리기

- 컴파일러가 컴파일하기 전에 먼저 수행하는 명령어
- 사용할 라이브러리 결정, 컴파일 조건, 상수값의 정의 등 프로그램 수행에 필요한 여러 사양을 결정

6.5.3.2. 전처리기 종류

- `#include`문: header 파일을 프로그램에 포함한다.
  - 헤더파일: 특정한 기능을 가지는 함수들의 정의를 담은 파일
  - 필요한 기능만 포함시켜서 메모리 낭비와 속도 저하를 방지한다.
  - `#include <avr/io.h>`: 환경에서 정의된 경로에서 io.h 파일을 찾아서 포함한다.
  - `#include "user1.h` : 현재 폴더에서 찾고, 없으면 정의된 경로에서 찾음
  - `math.h`: 수학함수(삼각함수, 로그 함수 등)
  - `stdlib.h` : 문자열 관련 함수
- 사용하고 싶은 함수를 선정하고 gcc 라이브러리 매뉴얼을 참조해서 헤더 파일을 포함한다.
- `io.h`: AVR의 GPIO(General Propose Input Output) 포트 입출력을 담당하는 함수 및 매크로

- `#define`문 : 상수를 정의한다.
  - 상수를 정의하여 프로그램에 컴파일 전에 치환한다.
  - `#define PI 3.141592`
  - MACRO를 정의한다.
  ```c
  #define example(x, y) (x) * (x) + (y) * (y)
  a = example(1, 5); // a = 1 * 1 + 5 * 5로 치환된다. 
  ```

- `typedef문`: 자료형을 재정의 한다.
```c
typedef unsigned int u_16
unsigned int i = 0;
u_16 j = 0;
```

6.5.3.3 전처리를 이용한 선택적 컴파일

* 조건을 판단하고 이에 따라 컴파일하는 영역을 선택한다.
* 두번 컴파일 하는 것을 방지한다.

전처리 구문 | 기능
---------|------
#undef | 정의된 매크로 해제
#ifdef | 정의되어 있으면 실행
#ifndef | 정의되어 있지 않으면 실행
#if | 참인 경우 실행
#elif | #else if
#else | 거짓인 경우 실행
#endif | #if문 종료
#line | 소스코드 행 번호 출력
#pragma | 컴파일러마다 다름

* io.h 파일과 main.c

```c
// main.c
#include <avr/io.h> // 1. io.h 파일을 include 함
#include <avr/io.h> // 5. io.h 파일을 다시 한 번 include 함

int main(void) {
  ...
}
```

```h
// io.h
#ifdef _AVR_IO_H_   // 2. _AVR_IO_H_ 는 정의되어 있지 않으므로
#define _AVR_IO_H_  // 3. _AVR_IO_H_ 를 정의함
...                 // 4. #ifndef ~ #endif 사이의 내용을 컴파일에 포함시킴
...
...
#endif              // 6. _AVR_IO_H_는 의미 정의되어 있으므로 #ifndef ~ #endif 사이의 내용을 컴파일에서 제외시킴
```

* 다양한 라이브러리 중 필요한 라이브러리만 컴파일에 포함시킨다.

```h
// io.h
...
#include <avr/sfr_defs.h>

#if defined ((__AVR_AT94K__)
#  include <avr/ioat94k.h>
#elif defined (__AVR_AT3USB320__)
#  include <avr/io43u32x.h>
...
#elif defined (__AVR_ATmega128__) // _AVR_ATmega128__이 정의되어 있으ㅡ면 iom.128.h파일을 컴파일에 포함시킨다.
# include <avr/iom128.h>          // -> AVR의 여러 종류 중 ATMega128에 맞는 입출력이 정의된 헤더파일을 컴파일한다.
...
#endif
```

## 7. ATmega128의 I/O 포트란?

### 7.1 I/O 포트의 개요

#### 7.1.1 LED 점등 회로 및 스위치 입력 회로

7.1.1.1 LED 점등 회로

* LED(Light Emitted Diode): 전류가 흐르면 점등되는 다이오드
* 입출력 장치로 LED 구동시, 2가지 회로로 구성 가능

출력 장치의 용도에 따른 포트의 전압과 AVR의 값 관계

용도 | 전압 | 값(이진수) | 의미
----|-----|---------|-----
전류의 싱크(Sink)로 사용 | 0V | 0 | True, 켜짐
전류의 소스(Source)로 사용 | 5V | 1 | True, 켜짐
전류의 싱크(Sink)로 사용 | 5V | 1 | False, Off
전류의 소스(Source)로 사용 | 0V | 0 | False, 꺼짐

7.1.1.2 방법

(1) 출력 장치를 전류의 싱크로 사용하는 경우

* AVR에서 0을 출력하면 출력 단자의 전압은 0V가 되므로, 다이오드에 순방향 바이어스가 걸리고 전류가 흘러 LED에 불이 켜짐 (출력과 점등이 반대)
* LED 점등 회로
  * 보호 저항 결정
    * LED 밝기는 전류의 세기에 비례, 저항이 작을수록 LED는 밝아짐
      * i = (5 - 1.5) / R : LED의 전압 강하(약 1.5V)를 고려
    * AVR의 입출력 전류: 한 포트당 최대 40mA 수준 -> 5V, 20mA 이하 권장 (Sink, Source 구분 없이)
    * TTL(Transistor-Transistor Logic)을 사용하여 LED 구동 -> 소스형 LED 구동 안 함 (TTL의 소스 전류: 매우 작음)
* 스위치 입력 회로
  * 입력 장치의 입력 핀: 0V -> 논리값 0을 Read
  * 입력 장치의 입력 핀: 5V -> 논리값 1을 Read

  * 스위치가 열리면, 입력 단의 전압이 0V가 아니고 떠있는 (Float) 상태가 됨 (1, 0으로 인식 불가)
    * 논리 입력 예측 불가 (오동작 유발)
  * 스위치가 열린 상태의 문제 해결: Pull Up 저항 사용
    * 스위치가 닫힌 경우: 입력 단은 접지와 연결되어 있으므로 스위치가 연결되면 전류가 접지에 흐르게 되므로 0V가 된다.
      * 따라서 마이크로프로세서는 논리값 0을 Read 한다.
    * 스위치가 열린 경우: 입력 단은 접지와 연결되어 있으므로, 스위치가 열리면 전류가 흐르지 않아 풀업 저항 사이의 전압 강하가 발생하지 않아 입력 단에는 5V가 걸린다.
      * 마이크로프로세서는 논리값 1을 Read 한다.
    * 입력 동작 -> 부논리
      * 어던 경우에도 Float 상태가 발생하지 않음
    스위치 | 입력
    -----|----
    닫힘 | 논리 0
    열림 | 논리 1

#### 7.1.2 ATmega128 I/O 포트

* 비트 단위의 Read-Modify-Write 기능을 갖는 7개의 범용 입/출력(I/O) 포트를 가지고 있다.

* 디지털 신호를 입력 받거나 출력(GPIO, General Propose Input Output)
  * 스위치 입력, LED 출력 등
  * 입력 기능과 출력 기능을 구분하여 사용
  * 대부분의 핀은 GPIO 기능을 가진다.
* PA0..7 ~ PG0..4까지 최대 53개의 포트를 가진다.
  * PC0은 PortC의 0번째 비트에 해당되는 핀을 의미하며, PC0의 핀 번호는 35이다.
  * PortA ~ F는 0 ~ 7까지 8개, PortG는 0~4까지 5개의 핀으로 구성된다.

* ATmega128 I/O 포트와 핀 구성
포트 | 비트 | 핀
----|-----|------------
PortA | 8bit | PA0 ~ PA7
PortB | 8bit | PB0 ~ PB7
PortC | 8bit | PC0 ~ PC7
PortD | 8bit | PD0 ~ PD7
PortE | 8bit | PE0 ~ PE7
PortF | 8bit | PF0 ~ PF7
PortG | 5bit | PG0 ~ PG7

* 관련 레지스터 설정으로 기능 선택
  * 대부분의 핀은 I/O 포트의 기능과 특수 기능을 가짐
  * 필요한 기능을 레지스터에서 설정함

  * PD1(SDA/INT1)
    * 입출력 포트
    * SDA: I2C 통신의 데이터
    * INT1: 외부 인터럽트 입력 1

#### 7.1.3 ATmega128 I/O 포트 기능

* PortA
  * 내부에 풀업 기능이 있는 양방향 8비트 포트로 입출력 방향과 데이터 값 제어
  * 2개의 레지스터(PORTA, ADDRA)와 1개의 입력 핀 상태 번지(PINA)로 구성
  * PortA 출력은 20mA까지 싱크(Sink)할 수 있어서 직접 LEN 구동이 가능하다.
  * PortA의 다른 (Alternative) 기능은 외부 메모리 접속시 address data low byte를 연결할 때 사용한다.
* PortB
  * 양방향 8비트 포트이며 기타 설명은 PortA와 같음
  * PortB의 다른 기능은 DDRB와 PORTB 레지스터를 사용하여 설정함에 따라 아래와 같이 다르다.

. | /SS (bit 0): Slave port Select Input | - SCK (bit 1): SPI 클럭(마스터 클럭 출력, 슬레이브 클럭 입력) | MOSI (bit 2): SPI 마스터 데이터 출력, 슬레이브 데이터 입력 | MISO (bit 3): SPI 마스터 데이터 입력, 슬래이브 데이터 출력
----|---|---|---|----
SPI가 슬래이브 모드 | 입력 상태로 됨 (DDB0과 무관), 이 입력이 0 상태일 때 SPI가 Enable 된다. | 입력 상태로 됨(DDB1과 무관) | 입력 상태로 됨 (DDB2과 무관) | DDB3의 설정 값에 따라 입출력 방향이 결정된다. 
SPI가 마스터 모드 | DDB0의 설정 값에 따라 입출력 방향이 결정된다. | DDB1의 설정 값에 따라 입출력 방향이 결정된다 | DDB2의 설정 값에 따라 입출력 방향이 결정된다. | 입력 상태로 된다 (DDB3과 무관하다)
입력 모드 | Pull-Up 상태로는 PORTB0 비트로 제어 | Pull-Up 상태는 PORTB1비트로 제어 | Pull-Up 상태는 PORTB2 비트로 제어 | Pull-Up 상태는 PORTB3 비트로 제어

  * OC0/PWM0 (bit 4)
    * 타이머 / 카운터 0의 Output Compare 출력 또는 타이머 / 카운터 0가 PWM 모드일 때 PWM 출력인데, 이 기능을 사용하기 위해서는 반드시 출력 방향으로 설정되어야 한다.
  * OC1A/PWM1A (bit 5)
    * 타이머 / 카운터 1의 Output Compare 출력 A또는 타이머 / 카운터 1가 PWM 모드일 때  PWM A 출력인데, 이 기능을 사용하기 위해서는 반드시 출력 방향으로 설정되어야 한다.
  * OC1B/PWM1B (bit 6)
    * 타이머 / 카운터 1의 Output Comapre 출력 B 또는 타이머 / 카운터 1가 PWM 모드일 때 PWM B 출력인데, 이 기능을 사용하기 위해서는 반드시 출력 방향으로 설정되어야 한다.
  * OC1C/PWM1C (bit 75)
    * 타이머 / 카운터2의 Output Compare 출력 또는 타이머 / 카운터 1가 PWM 모드일 때 PWM C 출력

* PortC
  * 양 방향 8비트 포트이며 기타 설명은 PortA와 같다.
  * PortC의 구분되는 기능은 ATMega 103모드일 때는 오직 출력으로만 사용되며 PORTC의 다른 기능으로는 외부 메모리 접속 시 어드레스 상위 byte에 연결된다.

* Port D
  * 양방향 8비트 포트이며 기타 설명은 PortA와 같다.
  * Port D의 다른 기능

기능 | 설명 
-----|-----
PD0 (bit 0) | 외부 인터럽트 0/TWI 시리얼 통신 클럭
PD1 (bit 1) | 외부 인터럽트 1/TWI 시리얼 통신 데이터
PD2 (bit 2) | 외부 인터럽트 2/UART1의 수신 핀
PD3 (bit 3) | 외부 인터럽트 3/UART1의 수신 핀
IC1(bit 4) | * 타이머 / 카운터 1의 입력 Capture 핀으로 상승 또는 하강 에지에서 (선택 가능)  타이머/카운터1 값이 Input Capture Resister로 래치된다. * 이 기능 사용시 입출력 방향은 당연히 입력 방향으로 해야 하고, Pull-up 기능을 활성화하여 사용해야 한다.
XCK1 (bit 5) | 외부클럭1, USART1의 외부클럭, 외부클럭1은 USART1이 동기모드일 때만 사용
T1 (bit 6) | 타이머/카운터1의 카운터 클럭 입력
T2 (bit 7) | 타이머/카운터2의 카운터 클럭 입력

* Port E
  * 양방향 8비트 포트이며 기타 설명은 PortA와 같다.
  * Port E의 다른 기능

기능 | 설명
-----|---------------------------------
PDI/RXD (bit 0) | Serial Programming Data Input / UART의 RXD, 직렬 다운 로드모드에서 데이터 입력 핀으로 사용되거나 UART의 RXD핀으로 사용 / UART의 수신이 Enable되면, DDRE0의 설정 값에 관계 없이 입력 모드로 되고, PORTE0를 1로 설정하면 내부 Pull-Up이 동작한다.
PDO/TXD (bit 1) | Serial Programming Data Output / UART의 TXD, 직렬 다운 로드모드에서 데이터 출력 핀으로 사용되거나 UART의 TXD핀으로 사용
AIN0/XCK0 (bit 2) | 아날로그 비교기 Positive 입력 또는 USART0의 외부 클럭 입력/출력
AIN1/OC3A (bit 3) | 아날로그 비교기 Negative 입력 또는 타이머/카운터3에 대한 비교 출력 및 PWM 출력 A
INT4/OC3B (bit 4) | 외부 인터럽트4 입력 또는 타이머/카운터3에 대한 비교 출력 및 PWM 출력 B
INT5/OC3C (bit 5) | 외부 인터럽트5 입력 또는 타이머/카운터3에 대한 비교 출력 및 PWM 출력 C
INT6/T3 (bit 6) | 외부 인터럽트6 또는 타이머/카운터3의 클럭 입력
INT7/IC3 (bit 7) | 외부 인터럽트7 또는 타이머/카운터3의 캡쳐 입력 트리거

* Port F
  * 양방향 8비트 포트이며 기타 설명은 PortA와 같다.
  * PORTF와 DDRF 레지스터는 ATmega103에서는 사용하지 못하며 입력으로만 사용

기능 | 설명
----|-----
PF0 (bit 0) | ADC 입력 채널 0번
PF1 (bit 1) | ADC 입력 채널 1번
PF2 (bit 2) | ADC 입력 채널 2번
PF3 (bit 3) | ADC 입력 채널 3번
PF4 (bit 4) | ADC 입력 채널 4번, JTAG 클럭
PF5 (bit 5) | ADC 입력 채널 5번, JTAG 테스트 모드 선택
PF6 (bit 6) | ADC 입력 채널 6번, JTAG 데이터 출력 핀
PF7 (bit 7) | ADC 입력 채널 7번, JTAG 데이터 입력 핀

* Port G
  * 양방향 5비트 포트이며 기타 설명은 PortA와 같음
  * Port G의 다른 기능

기능 | 설명
-----|--------
/WR (bit 0) | Write data, 외부 데이터 메모리를 쓰기 위한 strobe 제어 신호
/RD (bit 1) | Read data, 외부 데이터 메모리를 읽기 위한 strobe 제어 신호
PG2 (bit 2) | ALE, 외부 데이터 메모리를 Latch Enable 하기 위한 신호
PG3 (bit 3) | TOSC2, Real-Time Clockd을 위한 타이머/카운터 0, ASSR 레지스터의 AS0비트를 1로 하면 동기 클럭 입력으로 사용되며, I/O로 사용되지 못함(Timer OSC 핀 2)
PG4 (bit 4) | TOSC1, Real-Time Clockd을 위한 타이머/카운터 0, ASSR 레지스터의 AS0비트를 1로 하면 동기 클럭 입력으로 사용되며, I/O로 사용되지 못함(Timer OSC 핀 1)

### 7.2 입출력에 사용되는 레지스터

구분 | 세부 구분 | 레지스터
-----|----|----------
범용 I/O 포트와 관계된 레지스터 | 데이터 | PORTx
범용 I/O 포트와 관계된 레지스터 | 데이터 방향 설정 | DDRx
범용 I/O 포트와 관계된 레지스터 | 입력 핀 | PINx
특수 기능 입출력 | . | SFIOR

## 8. LED I/O 회로 설계

### 8.1 LED I/O 