# 프로그래밍의 개념

## 1. 프로그래밍 언어: 프로그램을 만들기 위해 사용하는 언어

## 2. 프로그램의 역사

* 프로그래밍이 가능한 최초의 기계 : 해석 기관( 찰스 배비지, 수천 개의 기어, 바퀴, 축, 레버 등으로 작동)
* 최초의 프로그래머: Ada Lovelace 
  * 핵심적인 컴퓨터 프로그래밍 기본 원리를 고안(subroutine, loop, jump) 
* 초기 컴퓨터의 프로그램: ENIAC의 프로그램
  * 스위치에 의해 기억되었고 프로그램을 변경할 때마다 그 많은 스위치들을 처음부터 다시 연결
  * 시간이 많이 걸림
* 프로그램 내장방식(1945)
  * 1945년 폰 노이만(Von Neumann) 제안
  * 컴퓨터에 기억장치를 설치하고, 프로그램과 데이터를 함께 기억장치에 저장했다가, 프로그램에 포함된 명령에 따라 자동으로 작업을 처리하는 방식
  * 주기억장치에서 명령어들을 순차적으로 가져와서 실행
* 최초의 실용적인 프로그램 내장 방식의 컴퓨터 (EDVAC)
  * EDVAC: Electronic Discrete Variable Automatic Computer
  * 1948년
  * 최초의 이진수를 사용한 프로그램 내장 컴퓨터
  * 2진수로 되어 있는 데이터만 처리가 가능하다.

## 3. 프로그래밍 언어의 분류

### 3.1. 기계어 (Machine Language)

- 저급언어
- 0과 1로 이루어진 언어
- 컴퓨터가 이해할 수 있는 언어
- 하드웨어에 종속적이다.
- 기계어의 이진수를 기호로 표시한다.
- 특정 CPU에 의존적이다.
  - 특정 컴퓨터의 명령어(instruction)를 이진수로 표시한 것이다.

### 3.2. 어셈블리 언어 (Assembly Language)

- 0, 1 대신 ADD, MOV 등의 명령 기호(mnemonic symbol)로 기술
- 기계어보다는 더 높은 수준에서 프로그램을 작성하는 것이 가능하다.
- 기호와 CPU의 명령어가 일대일로 대응된다.
- CPU의 명령을 이진수로 표시한다.
- 특정 CPU에 의존적이다.
- 어셈블리어 예시
```
      MOV C, 100
      MOV A, 0
NEXT: ADD A, C
      SUB C, 1
      CMP C, 0
      JNE NEXT
      MOV TOTAL, A
```
- 어셈블러: 기호를 이진수로 변환하는 프로그램

### 3.3. 고급언어
- 고수준의 명령을 사용한다.
- CPU에 독립적이다.
- C, Java, C++, Python
- C언어의 예

```c
// C
#include <stdio.h>
int main(void) {
  int n = 1, sum = 0;
  while (n<=10) {
    sum = sum + n++;
  }
  printf("%d", sum);
  return 0;
}
```

```java
// java
public class HapEx{
  public static void main(String[] args) {
    int n=1, sum=0;
    while (n<=10) {
      sum = sum + n++;
  }
  System.out.println(sum);
}
}
```

```js
// javascript
<script>
var n=1, sum=0;
while (n<=10) {
  sum = sum + n++;
}
document.write(sum);
</script>
```

### 3.3. 고급언어(High-level Language)

* 번역기
  * 컴파일러
    * 고급 언어 문장을 기계어로 변환하는 프로그램
    * 번역기
    * 고급 언어 문장을 기계어로 변환하는 프로그램
    * 소스프로그램을 목적 프로그램으로 변환하는 프로그램
  * 인터프리터
    * 고급 언어 문장을 한 단계씩 번역하여 바로 실행해주는 프로그램
    * 해석기
    * 번역과 실행이 동시에 이루어짐
    * 고급 언어 문장을 한 단계씩 번역하여 바로 실행해주는 프로그램
    * 별도의 실행파일이 존재하지 않음

* 컴파일 언어
  * 컴파일에 의해 버역되는 프로그래밍 언어
  * 컴파일이 된 프로그램의 경우 일반적으로 인터프리터를 이용해 실행시키는 것보다 훨씬 빠르게 동작한다.

* 인터프리터 언어
  * 인터프리터에 의해 번역 및 실행되는 프로그래밍 언어
  * 종류: 자바스크립트, python
  * 장점
    * 별도의 컴파일 시간이 없음
    * 프로그램 수정이 간단함
    * 크기가 큰 소스코드의 경우 컴파일 시간이 오래 걸릴 수 있는데 인터프리터 언어의 경우 바로 실행이 가능하다.

### 3.4. 고급 언어 실행 과정

1. 에디터에서 소스파일 .c 파일을 만든다.
2. 컴파일러가 목적파일 .obj 로 만들어준다.
3. 링커가 실행파일 .exe로 만들어준다.
4. 로더(loader)가 주기억 장치에 실행파일을 로드시킨다.

## 2. 알고리즘

문제를 해결하는 절차 (방법)

### 2.1. 알고리즘 기술 방법

1. 자연어(natural language)
- 인간이 사용하는 언어
- 단어들을 명백하게 정의해야 함

2. 순서도(flowchart)
- 프로그램에서의 논리 순서 또는 작업 순서를 그림으로 표현하는 방법

3. 의사코드(Pseudo Code)
- 의사코드의 개념: 특정 프로그래밍 언어의 문법에 따라 쓰인 것이 아니라, 일반적인 언어로 코드를 흉내 내어 알고리즘을 써놓은 코드

## 3. C언어

### 3.1. 역사

* 1970년대 초 AT&T의 Dennis Ritchie에 의해 개발
* UNIX 운영 체제 개발에 필요하여 만들어짐
* 처음부터 전문가용 언어로 출발

### 3.2 특성

* 간결하다
* 효율적이다
* 하드웨어를 직접 제어하는 저수준의 프로그래밍도 가능하고 고수준의 프로그래밍도 가능하다
* 이식성이 뛰어나다
* 초보자가 배우기 어렵다

## 4. 프로그램 개발 과정

### 4.1. 코딩 단계
(1) 소스코드 작성:
  - 알고리즘의 각 단계를 프로그래밍 언어를 이용해서 기술
  - 편집(edit): 에디터를 이용해서 원하는 작업의 내용을 작성 
(2) 소스파일(source file)
  - 소스 코드가 들어 있는 텍스트 파일
  - 프로그래밍 언어 문법에 따라 작성된 파일
  - 예시: test.c
(3) 편집기(editor)
  - 간단한 텍스트 편집기(메모장, 워드패드)
  - 통합개발환경

### 4.2. 컴파일 단계
(1) 컴파일(Compile)
- 소스파일의 문장을 분석하여 문법에 맞는지 확인
- 소스파일 -> 기계어로 변환
- 목적 파일(object file)
  - 기계어로 변환된 파일
  - test.obj
(2) 링크(Link)
- 목적 파일들을 라이브러리 파일들과 연결하여 하나의 실행 파일 생성
- 실행 파일 (excutable file)
  - 실행이 가능한 파일
  - test.exe
(3) 컴파일러(Compiler)
- 소스 파일의 문장을 분석하여 문법에 맞는지 확인
(4) 컴파일 오류(Compile Error)
  - 컴파일러가 컴파일 도중에 발견한 문법, 철자 등의 오류
(5) 링커(Linker)
  - 목적 파일을 라이브러리 파일들과 연결하여 하나의 실행 파일을 생성하는 프로그램
(6) 라이브러리(Library) 파일
- 프로그래머들이 많이 사용하는 기능을 미리 작성해 놓은 파일
- 컴파일러에 내장
- 예: 입출력 기능, 파일 처리, 수학 함수 계산

### 4.3. 프로그램 오류(Error)

1. 컴파일 시간 오류 (Compile time Error)
- 컴파일 하는 중에 발생하는 오류
- 대부분 문법 오류

2. 실행시간 오류(Run time Error)
- 실행 중에 발생하는 오류
- 0으로 나누기
- 무한 루프

3. 논리 오류(Logic Error)
- 프로그래머가 의도하지 않은 결과가 나오는 경우

4. 에러
- 컴파일/링크가 불가능한 상태
- 심각한 오류

5. 경고
- 컴파일/링크는 가능하고 실행도 가능하나 잠재적인 문제를 일으킬 수 있는 오류
- 경미한 오류
- 수정하지 않아도 문제가 없는 경우가 종종 있음.

## 5. 프로그램 기본 구조

### 5.1 C언어

* 함수 기반 언어
* 하나 이상의 함수로 구성됨
* main() 함수는 반드시 필요 - 프로그램의 시작

### 5.2 함수

* 특정한 작업을 수행하도록 한 개 이상의 문장으로 구성된 독립된 코드

### 5.3 C프로그램의 기본 구조

```c
/* 기본 구조 */ // 주석
#include <stdio.h> // 전처리기 지시어
int main(void) { // 함수 시작 
  printf("Hello World!"); // 문장
  return 0;
} // 함수 종료
```

5.3.0 주석

* 프로그램의 실행에는 영향을 끼치지 않음
* 컴파일러는 주석을 무시한다.
* 아무리 많아도 실행 프로그램의 크기가 커지지 않는다.

5.3.1. 전처리기 지시어

        [전처리기(Preprocessor)]
        * 컴파일러가 번역하기 전에 처리한다.
        * 소스코드를 전처리기가 처리한 다음에 그 결과를 컴파일러가 번역한다.
        * 주로 헤더 파일을 추가하거나 매크로 상수나 매크로 함수를 사용할 때 사용한다

* 전처리기가 할 일을 가르쳐주는 문장
* C언어의 첫 번째 열에서 선언한다.
* `;` 으로 끝나지 않는다.
* `#`으로 시작하는 행
* 전처리기 지시어(directive)의 예시
  `#include` : 파일 내용으로 대체한다.
  `#define` : 전처리 중 뭔가를 정의해서 #ifdef 같은데서 쓰게 한다.
  `#if`
  `#error`

        헤더파일(header file)
        * 코드의 일부분이 들어있는 텍스트 파일
        * 컴파일러가 필요로 하는 정보를 가지고 있음
        * .h의 확장자를 가짐

* 새로 생긴 object를 가지고 preprocessor만 따로 돌리는 방법
`gcc -E file.c > result`

`#include <stdio.h>`
* 헤더 파일 stdio.h를 소스프로그램의 #include 위치에 포함시키라는 의미의 문장
  * 헤더파일: 코드의 일부분이 들어있는 텍스트 파일
* stdio.h:
  - stdard input output header file
  - 표준 입출력에 대한 라이브러리 함수들의 정의 포함
* 표준 입출력: 키보드로부터의 입력/모니터로의 출력

5.3.2 함수(Function)

(1) 함수의 기본 특성
* 입력 (argument) -> 출력 (return value) 만들어 내는 코드
* 특정 기능을 수행하는 문장들의 모임
* 특정한 작업을 수행하기 위하여 작성된 독립적인 코드
* 프로그램을 구성하는 기본적인 단위
* 종류: 사용자 정의 함수 / 라이브러리 함수
* 구성: 헤더 / 몸체

(2) 함수의 기본 구조

```c
int main(void) {
  ...
  return 0;
}
```
`int`: 함수의 반환 타입
`main`: 함수의 이름
`void`: 함수의 인자 타입

5.3.3. main 함수

* 프로그램의 시작/종료 위치를 의미하는 특별한 함수
* C프로그램은 반드시 한 개의 main() 함수를 포함해야 함
* C프로그램은 반드시 한 개의 main() 함수만 포함해야 함
* 대개 운영체제가 호출한다.
* main() 함수가 가장 먼저 수행된다.
* C언어 표준: main() 함수의 마지막에 정수 반환 규정
  * return 0; -> 함수가 정상적으로 종료되었다.
  * return 1; -> customize 해서 다른 명령어를 설정해주면 됨.

5.3.4. Statement(문장)

* 프로그램을 이루는 가장 기본적인 단위
* 문장 < 함수 < 프로그램
* 문장의 끝은 `;`로 끝나야 한다.

5.3.5. 기타

Indentation(들여쓰기)

* 소스코드의 가독성을 높임
* 같은 수준에 있는 문장들을 왼쪽 끝에서 몇 자 안으로 들여쓰는 것

## 6. 프로그램 작성 규칙

### 6.1 작성 규칙

* 모든 문장은 세미콜론(;)으로 끝난다.
* 가능하면 한 줄에 한 개의 문장만 사용한다.
* 블록은 중괄호 ({})를 사용하여 구분한다.
* 빈칸과 공백줄을 적절히 사용한다.
* 블록에 있는 문장들은 들여쓰기 해야 한다.

## 7. 변수, 수식, 연산의 이해

### 7.1 변수

7.1.1 변수(Variable)

* 프로그램이 사용하는 데이터를 일시적으로 저장할 목적으로 사용하는 메모리 공간
* 변수 선언: 컴파일러에게 어떤 타입의 변수가 사용되는지를 미리 알리는 것

```c
// 변수 선언 및 값 대입
char ch;      // 문자형 변수 선언
int iData;    // 정수형 변수 선언 
double dData; // 실수형 변수 선언

ch = 'a';  // 변수 ch에 문자 'a'를 대입
iData=60;  // 변수 iData에 60을 대입
dData=4.9; // 변수 dData에 4.9를 대입

```

* 변수 초기화
`char ch = 'a'`
* 변수 사용
`int iData1 = 10;`
`int iData2 = 20;`
`iData2 = iData1;`

7.1.2 상수(Constant)

* 그 값이 프로그램이 실행하는 동안 변하지 않는 수
* ex: 100, 3.14, 'A'

### 7.2 자료형(Data Type)

* 자료형: 변수가 저장할 데이터가 어떤 타입인지를 정하는 것
  * 표준 자료형
    * 정수형: `short`, `int`, `long`
    * 실수형: `double`, `float`
    * 문자형: `char`

### 7.3 수식(Expression)

* 상수, 변수, 연산자의 조합
* 연산자와 피연산자로 구성된 식

### 7.4 연산

* 대입연산(assignment operation): 변수에 값을 저장하는 연산
  * 대입연산 = 배정연산 = 할당연산
* 산술연산
`iSum = x+y;`
* 연산자
  * 덧셈: x+y
  * 뺄셈: x-y
  * 곱셈: x*y
  * 나눗셈: x/y
  * 나머지: x%y

## 8. 기본 입출력 함수

### 8.1 식별자 개념과 규칙

식별자(identifier): 구별하기 위해 사용되는 이름

* 식별자의 종류
  * 변수명
  * 배열명
  * 함수명
  * 구조체명

* 키워드(keyword, 또는 예약어: reserved word)
  * C언어에서 고유한 의미를 가지고 있는 특별한 단어

      auto double int struct
      break else long switch
      case enum register typeder
      char extern return union
      const float short unsigned
      continue for signed void
      default goto sizeof volatile
      do if static while

### 8.2 변수명 작성 규칙

* 영문자, 숫자, 밑줄(_) 사용 가능
* 첫 번째 문자는 반드시 영문자 또는 밑줄(_) 이어야 함
* 예약어 사용 불가
* 특수문자 사용 불가 (밑줄 제외)
* 대소문자 구별함

* 좋은 변수 이름
  * 역할을 가장 잘 설명하는 이름
  * 여러 단어로 되어 있는 변수 이름
    * 단어와 단어는 밑줄로 연결
    * 단어의 첫문자는 대문자
  * 일관성 있게 사용하기

### 8.3 printf() 함수

1. 기능과 역할

* 기능: 모니터에 출력을 하기 위한 표준 출력 라이브러리 함수
* 예시: `#include <stdio.h>`

2. 역할

* 주어진 문자열을 출력한다.
* 주어진 값을 형식(format)에 맞춰 출력하는 기능

3. formatted 출력

* 예시
`printf("형식문자열", 출력할 값);`
`printf("%d", num);`
`printf("%d / %d = %f", num1, num2, result);`
`printf("1234\n")` != `printf("%d", 1234)` // 문자열 != 숫자
`printf("%d\n", 3/2);` // 1

* format specifier의 자료형과 변수의 자료형이 반드시 일치해야 한다.

      형식지정자(format specifier)
      * 값을 출력하는 형식을 지정
      * 형식지정자가 사용된 위치에 지정된 값을 출력
      * `%d`: 10진 정수로 출력 // `printf("%d", 10)`
      * `%f`: 실수로 출력 // `printf("%f", 3.2)`
      * `%c`: 문자로 출력 // `printf("%c", 'a')`
      * `%s`: 문자열로 출력 // `printf("%s", "abc")`

* 문자 폭(width) 지정
  * 커서 위치부터 왼쪽에서 오른쪽으로 출력됨
  * 문자 폭을 지정하면 문자 폭에 출력할 값의 오른쪽 끝을 맞춰 출력
  * 문자 폭을 지정하면 앞에 남는 부분에 빈칸 출력
  * 문자 폭과 함께 0을 지정하면 빈칸 대신 0으로 채워줌
  * 문자 폭보다 큰 값은 폭을 넘어서 출력한다

`printf("%d\n", 12345);`          // 12345
`printf("%d\n", 12345*1000);`     // 12345000
`printf("%8d\n", 12345);`         //    12345
`printf("%08d\n", 12345);`        // 00012345
`printf("%08d\n", 12345*100000);` // 1234500000

* 정밀도(precision) 지정
  * 실수를 출력할 때 소수점 이하 6자리로 출력 (디폴트)
  * 정밀도: 소수점 이하 자릿수
  * 정밀도 지정
    - `.`: 다음에 정수로 지정
    - `%.2f`: 소수점 이하 2자리를 출력하라는 의미
    - `%8.2f`: 소수점을 포함하여 전체 8문자 폭으로 출력. 소수점 이하 2자리 출력하라는 의미
    - 출력할 숫자의 자릿수를 의미함
    - `%8.4d`: 출력할 전체 8문자폭에 대해 정수를 4자릿수로 출력
      - 문자 폭의 남는 부분에는 빈칸 출력
      - 정밀도보다 출력할 정수의 개수가 적으면 0으로 출력

`printf("%f\n", 12.34567);`    // 12.345670
`printf("%.2f\n", 12.34567);`  // 12.35
`printf("%8.2f\n", 12.34567);` //    12.35
`printf("%8.4d\n", 123);`      //    0123

4. 제어 문자(Escape Sequence)

* print 목적이 아니라 제어 목적으로 사용되는 문자들
* `\0`: 널문자, 문자열의 끝
* `\n`: 줄바꿈(newline): 다음 라인의 시작 위치로 커서 이동
* `\t`: 텝문자(tab): 다음 탭 위치로 커서 이동
* `\'`: 작은 따옴표: 원래의 작은따옴표 출력
* `\"`: 큰 따옴표: 원래의 큰 따옴표 출력
* `\\`: 역슬래시 : 원래의 역슬래시 출력

### 8.4 scanf() 함수

`#include<stdio.h>`

1. 기능과 역할

* 기능: 키보드로부터 입력을 하기 위한 표준 입력 라이브러리 함수
* 역할
  - 키보드로부터 값을 받아서 변수에 저장
  - 변수의 **주소** 사용
  - 입력되는 데이터의 형식을 지정할 수 있음
* 특징: 여러 개를 입력할 수 있음

2. 형식

`scanf("%d", &x);` // `%d`: 형식지정자, `&x`: 값을 저장할 변수의 주소
`scanf("%d%d", &x, &y);` // 여러 변수 입력이 가능하다.

      형식지정자(format specifier)
      * 값을 입력하는 형식을 지정
      * `%d`: 10진 정수로 입력 // `scanf("%d", &i)`
      * `%f`: float로 입력 // `scanf("%f", &f)`
      * `%lf`: double형 실수로 입력 // `scanf("%lf", &d)`
      * `%c`: 문자로 입력 // `scanf("%c", &c)`
      * `%s`: 문자열로 입력 // `scanf("%s", s)`

### 8.5 printf()와 scanf() 활용하기

```c
int a, b;
prtinf("숫자를 두 개 입력하세요:");
scanf("%d%d, &a, &b);
printf("입력한 수는 %d과 %d입니다.\n", a, b);
```

# 8.3 변수와 상수의 개념

### 8.3.1. 변수의 개념

* 변수(variable)
  * 프로그램에서 일시적으로 데이터를 저장하는 공간
  * 데이터처리 위해 주기억장치의 특정 공간에 이름을 붙인 것
  * 데이터를 담는 container
    * container에 담을 데이터의 크기와 종류에 따라 다른 container를 사용한다.
    * 변수도 처리할 데이터에 따라 각기 다른 종류를 사용한다.
  * 변수는 데이터를 처리하기 위해 사용된다.
  * 변수는 서로 구분하기 위해 이름을 가진다.
  * 변수는 값을 저장하기 위해 메모리에 위치한다.

### 8.3.2 프로그램 내장 방식과 변수

* 프로그램 내장 방식 (Stored Program)
  * 컴퓨터에서 처리할 명령과 데이터를 주기억장치에 기억시켜 사용한다.
  * 주기억장치의 주소(address)
    * 1byte 단위
    * 0번지, 1번지, 2번지
  * 프로그램 내장방식이나 프로그램 코드에 직접 값을 넣는 것보다 보다 변수를 사용하는 것이 프로그램의 유연성을 높인다.

### 8.3.3 변수와 상수

* 변수(Variable): 프로그램 수행 중에 그 값이 변할 수 있는 데이터
* 상수(Constant): 프로그램 수행 중에 그 값이 변하지 않는 데이터
  * 리터럴 상수(Literal Constant): 이름이 붙지 않는 상수
    * 정수 상수: 소수가 없는 값
    * 실수 상수: 소수가 있는 값
    * 문자 상수: 1개의 문자를 표현하는 값(작은 따옴표 사용)
    * 문자열 상수: 1개 이상의 문자를 표현하는 값(큰 따옴표 사용)
  * 기호 상수(Symbolic Constant): 이름이 붙는 상수
    * 장점: 가독성이 높아지고 값을 쉽게 변경할 수 있다.
    * 3.14를 PI로 지정, 또는 0.1을 TAX_RATE로 지정
    * 선언 방법(1): `#define EXRATE 1200` // `;` 쓰지 않음. 문장이 아니라 단순히 기호를 값으로 대체하라고 전처리기에 알려준다.
    * 선언 방법(2): `const int EX_RATE = 1200;`
  * 정수 상수
    * 소수점 없이 사용하는 값
    * 모든 정수형 상수 앞에는 부호를 붙일 수 있음. - 생략하면 양의 정수로 취급
    * 기본형: int로 취급
    * 종류: 10진 상수, 8진 상수, 16진 상수, long형 상수
    * 예시:
      * `int x = 10; // 10진수`
      * `int y = 010; // 8진수`
      * `int z = 0x10; // 16진수`
      * `printf("x=%d", x);`
      * `printf("y=%d", y);`
      * `printf("z=%d", z);`
      * `int a;`, `a = 10;`, `printf("%d = %o(%d)\n", a, a, 8);`, `printf("%d = %d(%d) \n", a, a, 10);`, `printf("%d = %x(%d)\n", a, a, 16);` // octal: 8진법의, decimal: 10진법의, hexadecimal: 16진법의
  * 문자 상수
    * 1개의 문자 값
    * 메모리에 저장될 때 ASCII 코드 이용
    * 작은 따옴표 사용하여 표현함
    * 이스케이프 문자(Escape Character)
      * 문자 중에 개행 문자, 백스페이스 등과 같이 화면으로 출력되지 않는 문자
      * C언어에서 특별한 의미로 사용되는 문자
      * `\0` : 널문자 - 문자열의 끝
      * `\n` : 줄바꿈(new line) - 다음 라인의 시작 위치로 커서 이동
      * `\t` : tab문자 - 다음 탭 위치로 커서 이동
      * `\'` : 작은 따옴표 - 원래의 작은따옴표 출력
      * `\"` : 큰 따옴표 - 원래의 큰따옴표 출력
      * `\\` : 역슬러시 - 원래의 역슬러시 출력
    * ASCII 코드 일부

### 8.3.4 변수 선언

1. 변수 선언

* 컴파일러에게 어떤 변수를 사용하겠다고 미리 알리는 것
* 변수 선언은 변수 사용 전에 위치해야 함
* 형식: `int index;`(자료형 변수이름 )

2. 변수 선언의 예시

* `int a;` -> 정수형 변수 a를 만들기 위해 필요한 공간을 메모리에 확보하고 그 기억 공간에 a라는 이름을 붙인다.
* `int a, b, c;`, `char ch, hi;`, `float fData, width, length;` -> 같은 자료형을 갖는 여러 개의 변수 선언

3. 필요성

* 프로그램을 치밀하게 설계할 수 있어 성능이 향상된다.
* 프로그램 오류를 줄일 수 있다.
* 변수 관리 용이
* 프로그램에 대한 이해도 높일 수 있다.

4. 값 할당

* 상수의 자료형에 따른 저장 : 배정 연산자(할당 연산자)
* `char ch;`, `ch = 'a';`

5. 초기화

* 변수의 선언과 동시에 값을 할당하는 것
* `char ch = 'a';`

6. 자동 초기화

* 변수의 종류에 따라 다르다.
  * 예외 : 지역변수
    * 함수 안에서 선언된 변수
    * 자동 초기화되지 않음
    * 쓰레기값(garbage value)

## 8.4 데이터형

### 8.4.1 자료형(Data Type)

* 저장하는 데이터의 크기에 따라 필요한 메모리 공간의 크기가 다르다.
* 데이터 종류에 따라 변수의 종류를 다르게 하는 것이 효율적이다.
* 적절한 자료형을 사용하면 메모리가 절약되고 실행 속도도 향상된다.

1. 자료형의 종류

* `short`, `int`, `long`, `long`: 정수형 데이터
* `double`, `float`: 실수형 데이터
* `char`: 문자형 데이터

1.1 정수형

* 부호 있음
datatype | description | byte | range
---------|-------------|------|-------
short | short형 정수 | 2 | -32768 ~ 32767
int | 정수 | 4 | -2147483648 ~ 2147483647
long | long형 정수 |4 | -2147483648 ~ 2147483647
longlong | . | 8 | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807

      * short는 short int의 줄임
      * long은 long int의 줄임
      * long int 32비트 CPU에서 4바이트, 64비트 윈도우에서 4바이트, 64비트 리눅스에선 8바이트
      * long long int // 거의 항상 8바이트

* 부호 없음
datatype | description | byte | range
---------|-------------|------|-------
unsigned short | 부호 없는 short형 정수 | 2 | 0 ~ 65535
unsigned int | 부호 없는 정수 | 4 | 0 ~ 4294967295
unsigned long | 부호 없는 long형 정수 | 4 | 0 ~ 4294967295

1.2 문자형

1.2.1 아스키코드

* 문자는 컴퓨터보다는 인간에게 중요하다.
* 문자도 숫자를 이용하여 표현한다.
* 공통적인 규격이 필요해 ASCII(American Standard Code for Information Interchange) 코드 탄생

* 부호 있음
datatype | description | byte | range
---------|-------------|------|-------
char | 문자 및 정수 | 1 | -128 ~ 127

* 부호 없음
datatype | description | byte | range
---------|-------------|------|-------
unsigned char | 문자 및 부호 없는 정수 | 0 ~ 255

1.2.2 제어 문자

* print할 목적이 아니라 제어할 목적으로 사용되는 문자들

제어문자 | 이름 | 의미
-------|------|----
\0     | 널문자 | 문자열의 끝 표시
\a     | 경고(bell) | "삐"하는 경고음 발생
\b     | backspace | 커서를 현재의 위치에서 한 글자 뒤로 옮김
\t     | horizontal tab | 커서의 위치를 현재 라인에서 설정된 다음 탭 위치로 옮김
\n     | newline | 커서를 다음 라인의 시작 위치로 옮김
\v     | vertical tab | 설정되어 있는 다음 수직 탭 위치로 커서를 이동
\f     | form feed | 주로 프린터에서 강제적으로 다음 페이지로 넘길 때 사용
\r     | carriage return | 커서를 현재 라인의 시작 위치로 옮김
\"     | 큰따옴표 | "
\'     | 작은따옴표 | '
\\     | back slash | \

1.3. 실수형

실수 표현 방법에는 고정 소수점 방식과 부동소수점 방식이 있다.

1.3.1 고정소수점(Fixed Point)

* 소수점 위치를 고정시키고 정수부와 소수부를 나누어 표현한다.

1.3.2 부동소수점(Floating Point)

* 컴퓨터에서 실수는 부동소수점형으로 표현한다.
* 과학자들이 많이 사용하는 과학적 표기법과 유사하다.
  * 1.495 (실수의 정밀도) * 10^5 (실수의 표현 범위)

datatype | description | byte | range
------------|-------------|------|-------
float       | 단일정밀도 부동소수점 | 4 | 1.2E-38 ~ 3.4838
double      | 두배정밀도 부동소수점 | 8 | 2.2E-308 ~ 1.8E308
long double | 두배정밀도 부동소수점 | 8 | 2.2E-308 ~ 1.8E308

      * long double은 CPU마다 다르고 보통은 double과 같음. 간혹 (아주 옛날 CPU에서) 80bit floating point 일 때가 있음.

### 8.4.2 자료형 크기

      CPU 상관 없이 무조건 성립하는거:
      * char 는 무조건 1바이트
      * signed, unsigned 크기에 영향 안준다.
      * char <= short <= int <= long <= long long 이것도 항상 성립한다.

* `sizeof()`: 자료형의 크기(byte 단위) 반환하는 연산자
* 예시:
  * `sizeof(x)` // 변수
  * `sizeof(10)` // 값
  * `sizeof(int)` // 자료형

### 8.4.3 선언

1. 정수형 선언

* `short grade;` // short형 변수 선언
* `int count;` // int형 변수 선언
* `long distance;` // long형 변수 선언

2. 문자형 선언

* `char c;`
* `char answer;`
* `char code;`

* char 형의 변수에 문자를 저장하려면 아스키코드 값을 대입하면 된다.
  * `code = 65;` // 'A' 저장
  * `code = 'A';`

```c
/* 문자 변수와 문자 상수 */
#include <stdio.h>

int main(void) {
  char c1 = 'A';
  char c2 = 65;

  // 서로 같은 값이 출력된다.
  printf("문자 상수 초기화 = %c \n", c1);
  printf("아스키코드 초기화 = %c \n", c2);
  
  return 0;
}
```

*참고* 문자열은 `%s`로 표현할 것.

### 8.4.4 출력 형식 지정자

1. 정수형

* 기본 형식 지정자: `%d`

```c
int data = 5;

printf("%d\n", data);    // 5
printf("%5d\n", data);   //     5
printf("%5.2d\n", data); //    05
```

2. 실수형

* 기본 형식 지정자: `%f`
* 기본: 소수점 6자리까지만 출력된다.

```c
double d = 0.123456789;

printf("%f\n", d);      // 0.123457 
printf("%10.8f\n", d);  // 0.12345679
printf("%10.3f\n", d);  //      0.123
```

## 8.5 Overflow와 Underflow

### 8.5.1 Overflow

* 변수가 나타낼 수 있는 범위를 넘는 숫자를 저장하려고 할 때 발생
* 정수형에서 오버플로우 발생하면 경고가 없다.

```c
/* 정수형에서의 Overflow */
#include <stdio.h>
#include <limits.h>

int main(void) {
  short s = SHART_MAX; // 최대값(32767)
  unsigned short us = USHART_MAX; // 최대값(65535)

  printf("s=%d\n", s);
  s += 1 // 오버플로우가 발생한다.
  printf("s=%d\n", s);
  printf("us=%d\n", us);
  us += 1 // 오버플로우가 발생한다.
  printf("us=%d\n", us);
  return 0;
}
```

```c
/* 실수형에서의 overflow */
#include <stdio.h>

int main(void {
  float x = 1239;
  printf("x=%e\n", x);
  return 0;
}
```

### 8.5.2 Underflow

* 부동 소수점 수가 너무 작아서 표현하기 힘든 상황

```c
#include <stdio.h>

int main(void) {
  float x = 1.23456e-38;
  float y = 1.23456e-46; // 언더플로우 발생
  double z = 1.23456e-46;
  printf("x = %e\n", x);
  printf("y = %e\n", y);
  printf("z = %e\n", z);
  return 0;
}
```

## 9. 수식과 산술 연산자

1. 나머지 연산 (%)
  - 첫 번째 피연산자를 두 번째 피연산자로 나누어 나머지를 구함
  - 피연산자는 반드시 정수이어야 함

2. 대입 연산자 (Assignment Operator)
  - 할당연산자
  - 배정연산자
  - 왼쪽 변수에 오른쪽 수식의 결과값을 저장하는 연산자

3. Cast 연산자
  - 명시적인 형변환 (Type Cast)
  - 사용자가 데이터의 타입을 변경하는 것
  - 변환하고 싶은 자료형을 명시함

### 9.1 수식과 연산자의 개념

#### 9.1.1 수식(Expression)

1. 의미: 상수, 변수, 연산자의 조합
2. 구성: 연산자, 피연산자
3. 예시: `3 + 5`
  - 피연산자(operand) : 3, 5
  - 연산자(operator) : +
  - 결과값: 8

#### 9.1.2 연산자(Operator)

9.1.2.1. 기능에 따른 연산자 분류

연산자의 분류 | 연산자 | 의미
-----------|------|-----
대입        | `=`    | 오른쪽을 왼쪽에 대입
산술        | `+` `-` `*` `/` `%` | 사칙연산과 나머지 연산
부호        | `+` `-`  | 덧셈, 뺄셈 연산
증감        | `++` `--` | 증가, 감소 연산
관계        | `>` `<` `==` `!=` `>=` `<=` | 오른쪽과 왼쪽을 비교
논리        | `&&` `||` `!` | 논리적인 AND OR NOT
조건        | `?`    | 조건에 따라 선택
콤마        | `,`    | 피연산자들을 순차적으로 실행
비트 단위 연산자 | `&` `|` `^` `~` `<<` `>>` | 비트별 AND, OR, XOR, 반전 이동
sizeof 연산자 | `sizeof` | 자료형이나 변수의 크기를 바이트 단위로 반환
형변환 | `(type)` | 변수나 상수의 자료형을 변환
포인터 연산자 | `*` `&` `[]` | 주소 계산, 포인터가 가리키는 곳의 내용 추출
구조체 연산자 | `.` `->` | 구조체의 멤버 참조

9.1.2.2. 피연산자수에 따른 연산자 분류

* 단항 연산자: 피연산자의 수가 1개 `++x`
* 이항 연산자: 피연산자의 수가 2개 `3+5`
* 삼항 연산자: 피연산자의 수가 3개 `x?y:z`

9.1.2.3. 연산자 우선순위(Precedence)

우선순위 | 연산자 | 결합규칙
-------|------|-------
1 | `()` `[]` `->` `.` `++(후위)` `--(후위)` | `->`
2 | `sizeof` `&(주소)` `++(전위)` `--(전위)` `~` `!` `*(역참조)` `+(부호)` `-(부호)` 형변환 | <-
3 | `*(곱셈)` `/` `%` | ->
4 | `+(덧셈)` `-(뺄셈)` | ->
5 | `<<` `>>` | ->
6 | `<` `<=` `>=` `>` | ->
7 | `==` `!=` | ->
8 | `&(비트연산)` | ->
9 | `^` | ->
10 | `|` | ->
11 | `&&` | ->
12 | `||` | ->
13 | `?(삼항)` | <-
14 | `=` `+=` `*=` `/=` `%=` `^=` `|=` `<<=` `>>=` | <-
15 | ,(comma) | ->

### 9.1.3 산술연산자

9.1.3.1 정수 연산

1. 산술 연산자

- 컴퓨터의 가장 기본적인 연산
- 덧셈, 뺄셈, 곱셈, 나눗셈 등의 사칙 연산을 수행하는 연산자
- `y=a*x+b` `y=a*x*x + b*x + c` `y = (a+b+c)/3`

2. 정수 사칙연산 (`+` `-` `*` `/`)

- 피연산자가 모두 정수인 경우
- 결과도 정수가 된다.

3. 정수 나누기 연산 (`/`)

- 피연산자가 모두 정수인 경우
- 결과도 정수가 된다
  - `y=4/2` // y=2
  - `y=5/2` // y=2

4. 정수 나머지 연산 (Modulus Operator %)

- 첫 번째 피연산자를 두 번째 피연산자로 나누어 나머지를 구함
- 피연산자는 반드시 정수일 것
  - `5 % 2` // 1

9.1.3.2 실수 연산

1. 실수 사칙연산 (`+` `-` `*` `/`)

- 피연산자 중 하나 이상이 실수인 경우
- 결과는 실수가 됨
- `y = 10 + 5.0`

2. 실수 나누기 연산 (`/`)

- 피연산자 중 하나 이상이 실수인 경우
- 결과는 실수가 됨
  - 정수 / 실수 -> 실수
  - 실수 / 정수 -> 실수
  - 실수 / 실수 -> 실수

```c
#include <stdio.h>
int main() {
  int a = 5;
  int b = 2.;
  double div = a/b;
  printf("%d / %d = %f\n", a, b, div); // 2.5
  return 0;
}
```

9.1.3.3 대입 연산자 (Assignment Operator)

1. 대입 연산자: 왼쪽 변수에 오른쪽 수식의 결과값을 저장한다.

- 배정 연산자 또는 할당 연산자라고도 한다.
- `변수(variable) = 수식(expression);`
- `x=3;`

2. 복합 대입 연산자

- 대입 연산자와 다른 연산자를 합쳐 놓은 연산자
- 코드의 간결화

연산자 | 사용예 | 의미
------|------|-----
`+=`  | `x += a` | `x = x + a`
`-=`  | `x -= a` | `x = x - a`
`*=`  | `x *= a` | `x = x * a`
`/=`  | `x /= a` | `x = x / a`
`%=`  | `x % = a` | `x = x % a`

## 9.2 형변환

### 9.2.1 자동 형변환

1. 형변환(Type Conversion): 실행 중에 데이터의 타입을 변경하는 것

- 종류 : 자동 형변환, 명시적인 형변환(Cast 연산자)

1.1 자동 형변환

- 정수 연산시의 자동 형변환
  - 정수 연산시 char 형이나 short 형의 경우, 자동적으로 int형으로 변환하여 계산한다.
- 수식에서의 자동 형변환
  - 서로 다른 자료형이 혼합하여 사용되는 경우, 더 큰 자료형으로 통일하여 계산한다.

1.1.1 올림변환(Promotion): 정수형 상수를 실수형 변수에 저장 가능

```c
double d;
d = 10;
printf("%f", d); // 10.000000
```

1.1.2 내림변환(Demotion): 실수형 상수를 정수형 변수에 저장 가능
- 데이터 손실 발생 가능(소수점 이하 버림)
- 경고메시지 출력되니 유의하자.

```c
int x;
x = 3.14;
printf("%d", x); // 3
```

1.2 명시적인 형변환(Type Cast)

- 사용자가 데이터의 타입을 변경하는 것

`int 1.23456` // int형으로 변환한다.
`double x`    // double형으로 변환한다.
`long (x+y)`  // long형으로 변환한다.

```c
#include <stdio.h>
int main() {
  int a = 5;
  int b = 2;
  double div = double a/b; // 또는 a/ double b
  printf("%d / %d = %f\n", a, b, div);
  return 0;
}
```

## 10. 관계, 논리 연산자

### 10.1 증감연산자

#### 10.1.1 부호 연산자

1. 부호연산자
  - 변수나 상수의 부호를 변경
  - 단항 연산자(Unary Operator)
  - `x = -10;`, `y=-x;` // 변수 y의 값은 10

#### 10.1.2 증감 연산자

1. 증감연산자
  - `++`, `--`
  - 변수의 값을 하나 증가시키거나 감소시키는 연산자
  - 단항 연산자

증감연산자 | 의미 | 특징
--------|-----|-----
 `++x`  | 수식의 값은 증가된 x값 | 전위 | 값을 먼저 증가/감소시키고 증가/감소된 후에 값을 수식에 사용한다.
 `--x`  | 수식의 값은 감소된 x값 | 전위 | 값을 먼저 증가/감소시키고 증가/감소된 후에 값을 수식에 사용한다.
 `x++`  | 수식의 값은 증가되지 않은 원래의 x값 | 후위 | 수식의 값은 증가되지 않은 원래의 x값
 `x--`  | 수식의 값은 감소되지 않은 원래의 x값 | 후위 | 수식의 값은 감소되지 않은 원래의 x값

```c
int a = 10, b = 10;
int x, y;
x = ++a; // a=11,x=11
y = --b; // b=9, y=9
```

```c
int a = 10, b = 10;
int x, y;
x = a++; // a=11, x=10
y = b--; // b=9, y=10
```

### 10.2 관계연산자 (Relational Operator)

* 두 개의 피연산자를 비교하는 연산자
* 결과값은 참(1) 아니면 거짓(0)

연산자 | 의미
-----|------
`x==y` | x와 y가 같은가?
`x!=y` | x와 y가 다른가?
`x>y` | x가 y보다 큰가?
`x<y` | x가 y보다 작은가?
`x>=y` | x가 y보다 크거나 같은가?
`x<=y` | x가 y보다 작거나 같은가?

* `2 < x <5`로는 표현할 수 없다. x에 8이 들어올 수도 있기 때문
  * 따라서 `(2 < x) && (x < 5)`로 표현해야 한다.
* 관계연산자 사용시 주의점
  * 실수를 비교하는 경우 -> 실수는 약간의 오차가 있음
  * `(1e32 + 0.01) > 1e32`
  * 결과: 거짓 -> 실수는 약간의 오차가 있음

### 10.3 논리연산자 (Logical Operator)

* 여러 개의 조건을 조합해서 참과 거짓을 따지는 연산자
* 결과값은 참(1) 아니면 거짓(0)

연산자 | 의미
-----|-----
`x && y` | AND 연산 : x와 y가 모두 참이면 참, 그렇지 않으면 거짓
`x || y` | OR 연산 : x나 y중에서 하나만 참이면 참, 모두 거짓이면 거짓
`!x` | NOT 연산: x가 참이면 거짓, x가 거짓이면 참

#### 10.3.1 논리연산자의 계산 과정

* 논리연산의 결과값은 항상 1 또는 0
* `(1 == 2) || (2 == 2)` // 1

#### 10.3.2 참과 거짓의 표현 방법

* 관계/논리 수식이 만약 참이면 1, 거짓이면 0이 생성된다.
* 피연산자의 참, 거짓 판정: 0이 아니면 참, 0이면 거짓으로 판단한다.
* `!0` // 1 `!3` // 0 `!-3` // 0

#### 10.3.3 AND와 OR 연산자

* AND 연산자 (`&&`)
  * 두 개의 피연산자가 모두 참일 때만 연산 결과가 참이 됨
    * x는 60이상 100 미만이다.
      * `(x>=60) && (x<100)`
    * x가 0도 아니고1도 아니다.
      * `(x != 0) && (x != 1)`
  * 단축계산
    * `&&` 연산자의 경우 첫번째 피연산자가 거짓이면 다른 피연산자들을 계산하지 않음
    * `(2>3) && (++x<5)`

* OR 연산자 (`||`)
  * 두 개의 피연산자 중 하나 이상 참일 때 연산결과가 참이 됨
    * x는 1, 2, 3 중 하나인가?
      * `(x==1) || (x==2) || (x==3)`
  * 단축 계산
    * `||` 연산자의 경우 첫번째 피연산자가 참이면 다른 피연산자들을 계산하지 않음

* NOT 연산자 (`!`)
  * 피연산자의 값이 참이면 연산의 결과값은 거짓
  * 피연산자의 값이 거짓이면 연산의 결과값은 참
    * `result = !(2==3);`

* 조건 연산자
  * `max = (a > b)? a:b;`

* 콤마 연산자
  * 콤마로 연결된 수식은 순차적으로 계산한다.
  * `max = a, min = b;`

* 비트 연산자

연산자 | 의미 | 설명
------|-----|-----
`&` | 비트 AND | 두 개의 피연산자의 해당 비트가 모두 1이면 1, 아니면 0
`|` | 비트 OR | 두 개의 피연산자의 해당 비트 중 하나만 1이면 1
`^` | 비트 XOR | 두 개의 피연산자의 해당 비트의 값이 같으면 0, 아니면 1
`<<` | 왼쪽으로 shift | 지정된 개수만큼 모든 비트를 왼쪽으로 이동
`>>` | 오른쪽으로 이동 | 지정된 개수만큼 모든 비트를 오른쪽으로 이동
`~` | 비트 NOT | 0은 1로 만들고 1은 0으로 만듦

## 11. 조건문 IF

### 11.1 제어문의 이해

#### 11.1.1 제어구조

* 제어문 : 문장들이 실행되는 순서를 제어하는 문장
* 구조적 프로그래밍(Structure Programming)
  * 순차구조, 선택구조, 반복구조로만 작성된 프로그램
  * goto문을 사용하지 않는 프로그램

* 기본적인 제어구조
  * 순차구조(Sequence): 위에서 아래로 순서대로 실행하는 구조
  * 선택구조(Selection): 조건에 따라 둘 중 하나의 명령을 선택하여 실행하는 구조
  * 반복구조(Iteration): 조건이 만족하는 동안 일정 처리 과정을 반복 실행하는 구조

#### 11.1.2 IF문

11.1.2.1 if문의 개념

1. 기본 문법

```c
if (조건식) {
  명령문; // 조건식이 참인 경우에 실행
}
```

```c
#include <stdio.h>
int main(void) {
  int num;
  printf("정수 입력:");
  scanf("%d", &num);
  if (num < 0) {
    num = -num;
  }
  printf("절댓값: %d\n", num);
  return 0;
}
```

2. 조건식

- 수식으로 표현
- 관계 수식
  - `score >= 60`
  - `age >= 20`
  - `gender == 'female'`
- 논리 수식
  - `(score1 >= 60) && (score2 >= 60)`
  - `(dan >=2) && (dan <=9)`

11.1.2.2 복합문(블록, Compound Statement)

* 중괄호를 사용하여 문장들을 그룹핑하는 것
* 블록(block)
* 단일문 대신 들어갈 수 있음

```c
if (조건식) {
  명령문1;
  명령문2;
  명령문3;
}
```

11.1.2.3 참과 거짓

- 참과 거짓의 판정
  - 0이 아니면 -> 참
  - 0이면 -> 거짓

```c
if (x!=0) {
  printf("x는 0이 아님.");
}
```

는 다음과 같이 쓸 수 있다.

```c
if (x) 
  printf("x는 0이 아님.");
```

마찬가지로 다음 코드도

```c
if (x==0) {
  printf("x는 0이다.");
}
```

```c
if (!x) {
  printf("x는 0이다.");
}
```
로 바꿔 쓸 수 있다.

- 경고: 오류주의
  - if 문 조건식 뒤에 세미콜론이 없다.
  - 조건식에서 대등연산자와 대입연산자 혼동을 주의하자.
  - 조건식의 괄호는 생략 불가하다.

#### 11.1.3 IF-ELSE문

11.1.3.1 기본 문법

```c
if (조건식) {
  명령문1; // 조건식이 참인 경우에 실행한다.
} else {
  명령문2; // 조건식이 거짓인 경우에 실행한다.
}
```

11.1.3.2 삼항 연산자(Ternary Operator)

```c
if (num > 0) {
  printf("양수");
} else {
  printf("음수");
}
```
는 다음과 같이 쓸 수 있다.

```c
(num > 0) ? printf("양수") : printf("음수");

// ... 혹은 ...
printf(num > 0 ? "양수" : "음수");
```

#### 11.1.4 Nested If문

11.1.4.1 기본 IF문 형식

```c
if (조건식) {
  명령문;
}
```

11.1.4.2 IF-ELSE문

```c
if (조건식) {
  명령문1;
} else {
  명령문2;
} 명령문3;
```

11.1.4.3 Nested If문

* if문도 하나의 문장 `if(조건식) 문장;`
* if문 안에 다른 if문이 들어갈 수 있음
* 중첩 if문
  * if문을 한 번 실행하고, 그 결과에 다시 if문을 실행하는 것
  * if문 안에 또 다른 if문이 있는 것

```c
if (조건식1) {
  if (조건식2) {
    명령문1;
  }
}
```

```c
if (score>= 80) {
  if (score >= 90) {
    printf("A학점\n");
  } else {
    printf("B학점\n");
  }
} else {
  printf("F학점\n");
}
```

#### 11.1.5 다중 if문 (Multiple if문)

11.5.1.1 개념

* 서로 독립적인 조건을 여러 개 비교하는 경우
* else if로 연결되지 않은 if문
* 종류
  * 중첩 if문: if 문 안에 다른 if문이 있는 것
  * 연속적인 if문: 조건을 검사하고 다른 조건을 검사하고 또 다른 조건을 검사하는 것

  ```c
  fee = 10000;
  if (age >= 60) {
    fee = fee - 5000;
  }
  if (local == 1) {
    fee = fee - 5000;
  }
  ```
